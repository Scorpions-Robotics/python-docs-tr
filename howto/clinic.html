
<!DOCTYPE html>

<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<meta property="og:title" content="Argüman Kliniği Nasıl Yapılır" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/howto/clinic.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="yazar, Larry Hastings,. Soyut: Argüman Kliniği CPython C dosyaları için bir ön işlemcidir. Amacı, “builtins” için argüman ayrıştırma kodunun yazılmasıyla ilgili tüm boilerplate’i otomatikleştirmekt..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="yazar, Larry Hastings,. Soyut: Argüman Kliniği CPython C dosyaları için bir ön işlemcidir. Amacı, “builtins” için argüman ayrıştırma kodunun yazılmasıyla ilgili tüm boilerplate’i otomatikleştirmekt..." />
<meta property="og:image:width" content="200">
<meta property="og:image:height" content="200">
<meta name="theme-color" content="#3776ab">

    <title>Argüman Kliniği Nasıl Yapılır &#8212; Python 3.11.2 belgelendirmesi</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=845a48175c3935ba0d7ff16b8ed0072d62fd099f" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Python 3.11.2 belgelendirmesi içinde ara"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Bu belgeler hakkında" href="../about.html" />
    <link rel="index" title="Dizin" href="../genindex.html" />
    <link rel="search" title="Ara" href="../search.html" />
    <link rel="copyright" title="Telif Hakkı" href="../copyright.html" />
    <link rel="next" title="Instrumenting CPython with DTrace and SystemTap" href="instrumentation.html" />
    <link rel="prev" title="An introduction to the ipaddress module" href="ipaddress.html" />
    <link rel="canonical" href="https://docs.python.org/3/howto/clinic.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Hızlı Arama" aria-label="Hızlı Arama" type="search" name="q" />
                <input type="submit" value="Git"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">İçindekiler</a></h3>
    <ul>
<li><a class="reference internal" href="#">Argüman Kliniği Nasıl Yapılır</a><ul>
<li><a class="reference internal" href="#the-goals-of-argument-clinic">Argüman Kliniğinin Hedefleri</a></li>
<li><a class="reference internal" href="#basic-concepts-and-usage">Temel Kavramlar ve Kullanım</a></li>
<li><a class="reference internal" href="#converting-your-first-function">İlk Fonksiyonunuzu Dönüştürme</a></li>
<li><a class="reference internal" href="#advanced-topics">İleri Düzey Konular</a><ul>
<li><a class="reference internal" href="#symbolic-default-values">Sembolik varsayılan değerler</a></li>
<li><a class="reference internal" href="#renaming-the-c-functions-and-variables-generated-by-argument-clinic">Argüman Kliniği tarafından oluşturulan C işlevlerini ve değişkenlerini yeniden adlandırma</a></li>
<li><a class="reference internal" href="#converting-functions-using-pyarg-unpacktuple">PyArg_UnpackTuple kullanarak fonksiyonları dönüştürme</a></li>
<li><a class="reference internal" href="#optional-groups">İsteğe Bağlı Gruplar</a></li>
<li><a class="reference internal" href="#using-real-argument-clinic-converters-instead-of-legacy-converters">“Eski dönüştürücüler” yerine gerçek Argüman Kliniği dönüştürücülerinin kullanılması</a></li>
<li><a class="reference internal" href="#py-buffer">Py_buffer</a></li>
<li><a class="reference internal" href="#advanced-converters">Gelişmiş dönüştürücüler</a></li>
<li><a class="reference internal" href="#parameter-default-values">Parametre varsayılan değerleri</a></li>
<li><a class="reference internal" href="#the-null-default-value">Varsayılan değer <code class="docutils literal notranslate"><span class="pre">NULL</span></code></a></li>
<li><a class="reference internal" href="#expressions-specified-as-default-values">Varsayılan değerler olarak belirtilen ifadeler</a></li>
<li><a class="reference internal" href="#using-a-return-converter">Dönüş dönüştürücüsü kullanma</a></li>
<li><a class="reference internal" href="#cloning-existing-functions">Mevcut fonksiyonları klonlama</a></li>
<li><a class="reference internal" href="#calling-python-code">Python kodunu çağırma</a></li>
<li><a class="reference internal" href="#using-a-self-converter">“Kendi kendine dönüştürücü” kullanma</a></li>
<li><a class="reference internal" href="#using-a-defining-class-converter">“Sınıf tanımlama” dönüştürücüsü kullanma</a></li>
<li><a class="reference internal" href="#writing-a-custom-converter">Özel bir dönüştürücü yazma</a></li>
<li><a class="reference internal" href="#writing-a-custom-return-converter">Özel bir dönüş dönüştürücü yazma</a></li>
<li><a class="reference internal" href="#meth-o-and-meth-noargs">METH_O ve METH_NOARGS</a></li>
<li><a class="reference internal" href="#tp-new-and-tp-init-functions">tp_new ve tp_init fonksiyonları</a></li>
<li><a class="reference internal" href="#changing-and-redirecting-clinic-s-output">Kliniğin çıktısını değiştirme ve yönlendirme</a></li>
<li><a class="reference internal" href="#the-ifdef-trick">#ifdef hilesi</a></li>
<li><a class="reference internal" href="#using-argument-clinic-in-python-files">Python dosyalarında Argüman Kliniği kullanma</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Önceki konu</h4>
    <p class="topless"><a href="ipaddress.html"
                          title="önceki bölüm">An introduction to the ipaddress module</a></p>
  </div>
  <div>
    <h4>Sonraki konu</h4>
    <p class="topless"><a href="instrumentation.html"
                          title="sonraki bölüm">Instrumenting CPython with DTrace and SystemTap</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Bu Sayfa</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Hata Bildir</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/howto/clinic.rst"
            rel="nofollow">Kaynağı Göster
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Gezinti</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Genel Endeks"
             accesskey="I">dizin</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Modül Dizini"
             >modülleri</a> |</li>
        <li class="right" >
          <a href="instrumentation.html" title="Instrumenting CPython with DTrace and SystemTap"
             accesskey="N">sonraki</a> |</li>
        <li class="right" >
          <a href="ipaddress.html" title="An introduction to the ipaddress module"
             accesskey="P">önceki</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python NASIL’ları</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Argüman Kliniği Nasıl Yapılır</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Hızlı Arama" aria-label="Hızlı Arama" type="search" name="q" />
          <input type="submit" value="Git" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="argument-clinic-how-to">
<span id="howto-clinic"></span><h1>Argüman Kliniği Nasıl Yapılır<a class="headerlink" href="#argument-clinic-how-to" title="Permalink to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">yazar<span class="colon">:</span></dt>
<dd class="field-odd"><p>Larry Hastings</p>
</dd>
</dl>
<aside class="topic">
<p class="topic-title">Soyut</p>
<p>Argüman Kliniği CPython C dosyaları için bir ön işlemcidir. Amacı, “builtins” için argüman ayrıştırma kodunun yazılmasıyla ilgili tüm boilerplate’i otomatikleştirmektir. Bu dokümantasyon size ilk C fonksiyonunuzu Argüman Kliniği ile çalışacak şekilde nasıl dönüştüreceğinizi gösterir ve ardından Argüman Kliniği kullanımıyla ilgili bazı ileri düzey konuları tanıtır.</p>
<p>Şu anda Argüman Kliniği CPython için dahili olarak kabul edilmektedir.  CPython dışındaki dosyalar için kullanımı desteklenmemektedir ve gelecek sürümler için geriye dönük uyumluluk konusunda herhangi bir garanti verilmemektedir.  Başka bir deyişle: CPython için harici bir C uzantısına sahipseniz, Argüman Kliniği’ni kendi kodunuzda deneyebilirsiniz.  Ancak CPython’un bir sonraki sürümüyle birlikte gelen Argüman Kliniği sürümü * tamamen uyumsuz olabilir ve tüm kodunuzu bozabilir.</p>
</aside>
<section id="the-goals-of-argument-clinic">
<h2>Argüman Kliniğinin Hedefleri<a class="headerlink" href="#the-goals-of-argument-clinic" title="Permalink to this heading">¶</a></h2>
<p>Argüman Kliniği’nin birincil amacı CPython içindeki tüm argüman ayrıştırma kodunun sorumluluğunu üstlenmektir.  Bu, bir fonksiyonu Argüman Kliniği ile çalışacak şekilde dönüştürdüğünüzde, bu fonksiyonun artık kendi argüman ayrıştırmasını yapmaması gerektiği anlamına gelir - Argüman Kliniği tarafından üretilen kod sizin için bir “kara kutu” olmalıdır, CPython üstte çağırır ve kodunuz altta çağrılır, <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*args</span></code> (ve belki <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*kwargs</span></code>) sihirli bir şekilde ihtiyacınız olan C değişkenlerine ve türlerine dönüştürülür.</p>
<p>Argüman Kliniği’nin birincil amacına ulaşabilmesi için kullanımının kolay olması gerekir.  Şu anda, CPython’un argüman ayrıştırma kütüphanesi ile çalışmak, şaşırtıcı sayıda yerde gereksiz bilgileri korumayı gerektiren bir angarya. Argüman Kliniği’ni kullandığınızda, kendinizi tekrar etmek zorunda kalmazsınız.</p>
<p>Açıkçası, hiç kimse Argüman Kliniği’ni kendi sorununu çözmedikçe ve kendi başına yeni sorunlar yaratmadıkça kullanmak istemeyecektir. Bu yüzden Argüman Kliniği’nin doğru kod üretmesi çok önemlidir. Kodun daha hızlı olması da güzel olurdu, ancak en azından büyük bir hız gerilemesi getirmemelidir.  (Sonunda Argüman Kliniği <em>büyük bir hızlanmayı mümkün kılmalıdır</em> - genel amaçlı CPython argüman ayrıştırma kütüphanesini çağırmak yerine, özel argüman ayrıştırma kodu üretmek için kod oluşturucusunu yeniden yazabiliriz.  Bu, mümkün olan en hızlı argüman ayrıştırmasını sağlayacaktır!)</p>
<p>Ek olarak, Argüman Kliniği argüman ayrıştırmaya yönelik herhangi bir yaklaşımla çalışabilecek kadar esnek olmalıdır.  Python’un çok garip ayrıştırma davranışlarına sahip bazı fonksiyonları vardır; Argüman Kliniği’nin amacı bunların hepsini desteklemektir.</p>
<p>Son olarak, Argüman Kliniği’nin asıl motivasyonu CPython yerleşik bileşenleri için iç gözlem “imzaları” sağlamaktı. Eskiden, iç gözlem sorgu işlevleri, bir yerleşik geçerseniz bir istisna atardı.  Argüman Kliniği ile bu geçmişte kaldı!</p>
<p>Argüman Kliniği ile çalışırken aklınızda tutmanız gereken bir fikir var: Ona ne kadar çok bilgi verirseniz, o kadar iyi iş çıkaracaktır. Argüman Kliniği kuşkusuz şu anda nispeten basittir.  Ancak geliştikçe daha sofistike hale gelecek ve ona verdiğiniz tüm bilgilerle birçok ilginç ve akıllıca şey yapabilecektir.</p>
</section>
<section id="basic-concepts-and-usage">
<h2>Temel Kavramlar ve Kullanım<a class="headerlink" href="#basic-concepts-and-usage" title="Permalink to this heading">¶</a></h2>
<p>Argüman Kliniği CPython ile birlikte gelir; <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code> içinde bulabilirsiniz. Bu dizeyi çalıştırırsanız, argüman olarak bir C dosyası belirtirseniz:</p>
<div class="highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>python3<span class="w"> </span>Tools/clinic/clinic.py<span class="w"> </span>foo.c
</pre></div>
</div>
<p>Argüman Kliniği dosyayı tarayarak tam olarak buna benzeyen satırları arayacaktır:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*[clinic input]
</pre></div>
</div>
<p>Bir tane bulduğunda, tam olarak buna benzeyen bir satıra kadar her şeyi okur:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[clinic start generated code]*/
</pre></div>
</div>
<p>Bu iki satır arasındaki her şey Argüman Kliniği için girdidir. Başlangıç ve bitiş yorum satırları da dahil olmak üzere tüm bu satırlara topluca Argüman Kliniği “bloğu” denir.</p>
<p>Argüman Kliniği bu bloklardan birini ayrıştırdığında çıktı üretir.  Bu çıktı, bloktan hemen sonra C dosyasına yeniden yazılır ve ardından bir sağlama toplamı içeren bir yorum eklenir. Argüman Kliniği bloğu şimdi şöyle görünür:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/*[clinic input]
... clinic input goes here ...
[clinic start generated code]*/
... clinic output goes here ...
/*[clinic end generated code: checksum=...]*/
</pre></div>
</div>
<p>Argüman Kliniği’ni aynı dosya üzerinde ikinci kez çalıştırırsanız, Argüman Kliniği eski çıktıyı atacak ve yeni çıktıyı yeni bir sağlama toplamı satırıyla birlikte yazacaktır.  Ancak, girdi değişmemişse, çıktı da değişmeyecektir.</p>
<p>Bir Argüman Kliniği bloğunun çıktı kısmını asla değiştirmemelisiniz.  Bunun yerine, istediğiniz çıktıyı üretene kadar girdiyi değiştirin.  (Sağlama toplamının amacı budur - birisinin çıktıyı değiştirip değiştirmediğini tespit etmek, çünkü bu düzenlemeler Argüman Kliniği bir sonraki sefer yeni çıktı yazdığında kaybolacaktır)</p>
<p>Açıklık getirmek adına, Argüman Kliniği ile ilgili kullanacağımız terminolojiyi burada bulabilirsiniz:</p>
<ul class="simple">
<li><p>Yorumun ilk satırı (<code class="docutils literal notranslate"><span class="pre">/*[clinic</span> <span class="pre">input]</span></code>) <em>başlangıç satırıdır</em>.</p></li>
<li><p>İlk yorumun son satırı (<code class="docutils literal notranslate"><span class="pre">[clinic</span> <span class="pre">start</span> <span class="pre">generated</span> <span class="pre">code]*/</span></code>) <em>son satırdır</em>.</p></li>
<li><p>Son satır (<code class="docutils literal notranslate"><span class="pre">/*[clinic</span> <span class="pre">end</span> <span class="pre">generated</span> <span class="pre">code:</span> <span class="pre">checksum=...]*/</span></code>) <em>checksum line</em>.</p></li>
<li><p>Yorumun ilk satırı (<code class="docutils literal notranslate"><span class="pre">/*[clinic</span> <span class="pre">input]</span></code>) <em>başlangıç satırıdır</em>.</p></li>
<li><p>Bitiş satırı ile sağlama toplamı satırı arasında <em>çıktı</em> bulunur.</p></li>
<li><p>Başlangıç satırından sağlama toplamı satırına kadar tüm metin toplu olarak <em>blok</em>’tur.  (Argüman Kliniği tarafından henüz başarılı bir şekilde işlenmemiş bir bloğun çıktısı veya sağlama satırı yoktur, ancak yine de bir blok olarak kabul edilir)</p></li>
</ul>
</section>
<section id="converting-your-first-function">
<h2>İlk Fonksiyonunuzu Dönüştürme<a class="headerlink" href="#converting-your-first-function" title="Permalink to this heading">¶</a></h2>
<p>Argüman Kliniği’nin nasıl çalıştığını anlamanın en iyi yolu, bir fonksiyonu onunla çalışacak şekilde dönüştürmektir.  O halde burada, bir fonksiyonu Argüman Kliniği ile çalışacak şekilde dönüştürmek için izlemeniz gereken asgari adımlar yer almaktadır.  CPython’da kontrol etmeyi planladığınız kod için, belgede daha sonra göreceğiniz bazı gelişmiş kavramları (“dönüş dönüştürücüler” ve “öz dönüştürücüler” gibi) kullanarak dönüştürmeyi gerçekten daha ileri götürmeniz gerektiğini unutmayın. Ancak öğrenebilmeniz için bu kılavuz için basit tutacağız.</p>
<p>Hadi dalalım!</p>
<ol class="arabic" start="0">
<li><p>CPython trunk’ın yeni güncellenmiş bir checkout’u ile çalıştığınızdan emin olun.</p></li>
<li><p><a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> veya <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> çağıran ve henüz Argüman Kliniği ile çalışmak üzere dönüştürülmemiş bir Python yerleşik bileşeni bulun. Benim örneğim için <code class="docutils literal notranslate"><span class="pre">_pickle.Pickler.dump()</span></code> kullanıyorum.</p></li>
<li><p>Eğer <code class="docutils literal notranslate"><span class="pre">PyArg_Parse</span></code> fonksiyonuna yapılan çağrı aşağıdaki format birimlerinden herhangi birini kullanıyorsa:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>O&amp;
O!
es
es#
et
et#
</pre></div>
</div>
<p>veya <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> için birden fazla çağrı varsa, farklı bir işlev seçmelisiniz.  Argüman Kliniği bu senaryoların tümünü <em>destekler</em>.  Ancak bunlar ileri düzey konulardır - ilk fonksiyonunuz için daha basit bir şey yapalım.</p>
<p>Ayrıca, fonksiyonun aynı argüman için farklı türleri desteklediği <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> veya <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> için birden fazla çağrısı varsa veya fonksiyon argümanlarını ayrıştırmak için PyArg_Parse fonksiyonları dışında bir şey kullanıyorsa, muhtemelen Argüman Kliniğine dönüştürmek için uygun değildir.  Argüman Kliniği genel fonksiyonları veya çok biçimli parametreleri desteklemez.</p>
</li>
<li><p>Bloğumuzu oluşturmak için fonksiyonun üzerine aşağıdaki şablonu ekleyin:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>Doküman dizesini kesin ve <code class="docutils literal notranslate"><span class="pre">[clinic]</span></code> satırları arasına yapıştırın, düzgün bir şekilde alıntılanmış bir C dizesi haline getiren tüm gereksiz şeyleri kaldırın. İşiniz bittiğinde, 80 karakterden daha geniş bir satır olmadan, sol kenar boşluğuna dayalı olarak yalnızca metne sahip olmalısınız. (Argüman Kliniği, doküman dizesi içindeki girintileri koruyacaktır.)</p>
<p>Eğer eski dokümanda fonksiyon imzasına benzeyen bir ilk satır varsa, o satırı atın.  (Doküman dizesinin artık buna ihtiyacı yoktur - gelecekte yerleşik öğenizde <code class="docutils literal notranslate"><span class="pre">help()</span></code> kullandığınızda, ilk satır işlevin imzasına göre otomatik olarak oluşturulacaktır).</p>
<p>Örnek:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>Eğer doküman dizinizde bir “özet” satırı yoksa Argüman Kliniği şikayet edecektir.  Bu yüzden bir tane olduğundan emin olalım.  “Özet” satırı, doküman dizesinin başında 80 sütunlu tek bir satırdan oluşan bir paragraf olmalıdır.</p>
<p>(Örnek doküman dizimiz yalnızca bir özet satırından oluşmaktadır, bu nedenle örnek kodun bu adım için değişmesi gerekmez.)</p>
</li>
<li><p>Döküman dizisinin üstüne fonksiyonun adını girin ve ardından boş bir satır ekleyin.  Bu, işlevin Python adı olmalı ve işlevin tam noktalı yolu olmalıdır - modülün adıyla başlamalı, tüm alt modülleri içermeli ve işlev bir sınıf üzerindeki bir yöntemse sınıf adını da içermelidir.</p>
<p>Örnek:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>Eğer bu modül veya sınıf bu C dosyasında Argüman Kliniği ile ilk kez kullanılıyorsa, modülü ve/veya sınıfı bildirmeniz gerekir.  Uygun Argüman Kliniği hijyeni, bunları C dosyasının üst kısmına yakın bir yerde ayrı bir blokta bildirmeyi tercih eder, aynı şekilde include dosyaları ve statikler de en üstte yer alır. (Örnek kodumuzda sadece iki bloğu yan yana göstereceğiz).</p>
<p>Sınıfın ve modülün adı Python tarafından görülenle aynı olmalıdır. <a class="reference internal" href="../c-api/module.html#c.PyModuleDef" title="PyModuleDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyModuleDef</span></code></a> veya <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> içinde tanımlanan ismi kontrol edin.</p>
<p>Bir sınıfı bildirdiğinizde, C’deki türünün iki yönünü de belirtmeniz gerekir: bu sınıfın bir örneğine bir işaretçi için kullanacağınız tür bildirimi ve bu sınıf için <a class="reference internal" href="../c-api/type.html#c.PyTypeObject" title="PyTypeObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyTypeObject</span></code></a> işaretçisi.</p>
<p>Örnek:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>Her bir parametreyi fonksiyona ilan edin.  Her parametre kendi satırını almalıdır.  Tüm parametre satırları fonksiyon adından ve döküman dizisinden girintili olmalıdır.</p>
<p>Bu parametre satırlarının genel formu aşağıdaki gibidir:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>name_of_parameter: converter
</pre></div>
</div>
<p>Parametrenin varsayılan bir değeri varsa, bunu dönüştürücüden sonra ekleyin:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>name_of_parameter: converter = default_value
</pre></div>
</div>
<p>Argüman Kliniğinin “varsayılan değerler” desteği oldukça karmaşıktır; daha fazla bilgi için lütfen <a class="reference internal" href="#default-values"><span class="std std-ref">the section below on default values</span></a> bölümüne bakın.</p>
<p>Parametrelerin altına boş bir satır ekleyin.</p>
<p>“Dönüştürücü” nedir?  Hem C’de kullanılan değişkenin türünü hem de Python değerini çalışma zamanında C değerine dönüştürme yöntemini belirler. Şimdilik “eski dönüştürücü” denilen şeyi kullanacaksınız - eski kodu Argüman Kliniği’ne taşımayı kolaylaştırmak için tasarlanmış bir kolaylık dizesi.</p>
<p>Her parametre için, <code class="docutils literal notranslate"><span class="pre">PyArg_Parse()</span></code> format argümanından o parametrenin “format birimini” kopyalayın ve dönüştürücü olarak <em>bunu</em> tırnaklı bir dize olarak belirtin.  (“format unit”, <code class="docutils literal notranslate"><span class="pre">format</span></code> parametresinin bir ila üç karakterlik alt dizesinin resmi adıdır ve argüman ayrıştırma fonksiyonuna değişkenin türünün ne olduğunu ve nasıl dönüştürüleceğini söyler.  Biçim birimleri hakkında daha fazla bilgi için lütfen <a class="reference internal" href="../c-api/arg.html#arg-parsing"><span class="std std-ref">Parsing arguments and building values</span></a> bölümüne bakın)</p>
<p><code class="docutils literal notranslate"><span class="pre">z#</span></code> gibi çok karakterli format birimleri için iki veya üç karakterli dizenin tamamını kullanın.</p>
<p>Örnek:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="cm">/*[clinic input]</span>
<span class="cm"> module _pickle</span>
<span class="cm"> class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm"> [clinic start generated code]*/</span>

<span class="w"> </span><span class="cm">/*[clinic input]</span>
<span class="cm"> _pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>Eğer fonksiyonunuzun biçim dizesinde <code class="docutils literal notranslate"><span class="pre">|</span></code> varsa, yani bazı parametrelerin varsayılan değerleri varsa, bunu yok sayabilirsiniz.  Argüman Kliniği, varsayılan değerlere sahip olup olmadıklarına göre hangi parametrelerin isteğe bağlı olduğunu çıkarır.</p>
<p>İşlevinizin biçim dizesinde <code class="docutils literal notranslate"><span class="pre">$</span></code> varsa, yani yalnızca anahtar sözcüklerden oluşan bağımsız değişkenler alıyorsa, <code class="docutils literal notranslate"><span class="pre">*</span></code> ifadesini yalnızca anahtar sözcüklerden oluşan ilk bağımsız değişkenden önce, parametre satırlarıyla aynı şekilde girintili olarak tek başına bir satırda belirtin.</p>
<p>(<code class="docutils literal notranslate"><span class="pre">_pickle.Pickler.dump</span></code> ikisine de sahip değildir, bu nedenle örneğimiz değişmemiştir.)</p>
</li>
<li><p>Eğer mevcut C fonksiyonu <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> (<a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> yerine) çağrısı yapıyorsa, tüm argümanları sadece konumsaldır.</p>
<p>Argüman Kliniğinde tüm parametreleri sadece konumsal olarak işaretlemek için, son parametreden sonra tek başına bir satıra parametre satırlarıyla aynı şekilde girintili bir <code class="docutils literal notranslate"><span class="pre">/</span></code> ekleyin.</p>
<p>Şu anda bu ya hep ya hiçtir; ya tüm parametreler yalnızca konumsaldır ya da hiçbiri değildir.  (Gelecekte Argüman Kliniği bu kısıtlamayı gevşetebilir)</p>
<p>Örnek:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>Her parametre için parametre başına bir doküman yazmak faydalıdır. Ancak parametre başına dokümanlar isteğe bağlıdır; isterseniz bu adımı atlayabilirsiniz.</p>
<p>Parametre başına doküman dizisinin nasıl ekleneceği aşağıda açıklanmıştır.  Parametre başına doküman dizesinin ilk satırı parametre tanımından daha fazla girintili olmalıdır.  Bu ilk satırın sol kenar boşluğu, parametre başına doküman dizesinin tamamı için sol kenar boşluğunu belirler; yazdığınız tüm metin bu miktarda girintili olacaktır.  Dilerseniz birden fazla satıra istediğiniz kadar metin yazabilirsiniz.</p>
<p>Örnek:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</li>
<li><p>Dosyayı kaydedin ve kapatın, ardından <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code> dosyasını çalıştırın.  Şansınız varsa her şey işe yaradı— bloğunuzun artık bir çıktısı var ve bir <code class="docutils literal notranslate"><span class="pre">.c.h</span></code> dosyası oluşturuldu! Görmek için dosyayı metin düzenleyicinizde yeniden açın:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="n">_pickle_Pickler_dump</span><span class="p">(</span><span class="n">PicklerObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="cm">/*[clinic end generated code: output=87ecad1261e02ac7 input=552eb1c0f52260d9]*/</span>
</pre></div>
</div>
<p>Açıkçası, Argüman Kliniği herhangi bir çıktı üretmediyse, bunun nedeni girdinizde bir hata bulmasıdır.  Argüman Kliniği dosyanızı şikayet etmeden işleyene kadar hatalarınızı düzeltmeye ve yeniden denemeye devam edin.</p>
<p>Okunabilirlik için, tutkal kodunun çoğu bir <code class="docutils literal notranslate"><span class="pre">.c.h</span></code> dosyasında oluşturulmuştur.  Bunu orijinal <code class="docutils literal notranslate"><span class="pre">.c</span></code> dosyanıza eklemeniz gerekir, tipik olarak klinik modül bloğundan hemen sonra:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;clinic/_pickle.c.h&quot;</span>
</pre></div>
</div>
</li>
<li><p>Argüman Kliniği’nin ürettiği argüman ayrıştırma kodunun temelde mevcut kodla aynı göründüğünü iki kez kontrol edin.</p>
<p>İlk olarak, her iki yerin de aynı argüman ayrıştırma işlevini kullandığından emin olun. Mevcut kod <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> veya <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> fonksiyonlarından birini çağırmalıdır; Argüman Kliniği tarafından oluşturulan kodun <em>tam olarak</em> aynı fonksiyonu çağırdığından emin olun.</p>
<p>İkinci olarak, <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> veya <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> işlevine aktarılan biçim dizesi, iki nokta üst üste veya noktalı virgülüne kadar mevcut işlevde elle yazılmış olanla <em>tam olarak</em> aynı olmalıdır.</p>
<p>(Argüman Kliniği, biçim dizelerini her zaman <code class="docutils literal notranslate"><span class="pre">:</span></code> ve ardından işlevin adı ile oluşturur.  Mevcut kodun biçim dizesi, kullanım yardımı sağlamak için <code class="docutils literal notranslate"><span class="pre">;</span></code> ile bitiyorsa, bu değişiklik zararsızdır - bu konuda endişelenmeyin)</p>
<p>Üçüncü olarak, biçim birimleri iki bağımsız değişken gerektiren parametreler için (uzunluk değişkeni veya kodlama dizesi veya dönüştürme işlevine işaretçi gibi), ikinci bağımsız değişkenin iki çağırma arasında <em>tam olarak</em> aynı olduğundan emin olun.</p>
<p>Dördüncü olarak, bloğun çıktı kısmının içinde bu yerleşik: için uygun statik <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> yapısını tanımlayan bir önişlemci makrosu bulacaksınız:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define __PICKLE_PICKLER_DUMP_METHODDEF    \</span>
<span class="cp">{&quot;dump&quot;, (PyCFunction)__pickle_Pickler_dump, METH_O, __pickle_Pickler_dump__doc__},</span>
</pre></div>
</div>
<p>Bu statik yapı, bu yerleşik için mevcut statik <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> yapısı ile <em>tam olarak</em> aynı olmalıdır.</p>
<p>Bu öğelerden herhangi biri <em>herhangi bir şekilde</em> farklıysa, Argüman Kliniği işlev belirtiminizi ayarlayın ve <em>aynı</em> olana kadar <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code> dosyasını yeniden çalıştırın.</p>
</li>
<li><p>Çıktısının son satırının “impl” fonksiyonunuzun bildirimi olduğuna dikkat edin.  Bu, yerleşik uygulamanın gittiği yerdir. Değiştirdiğiniz fonksiyonun mevcut prototipini silin, ancak açılış küme parantezini bırakın.  Şimdi argüman ayrıştırma kodunu ve argümanları içine attığı tüm değişkenlerin bildirimlerini silin. Python argümanlarının artık bu impl fonksiyonunun argümanları olduğuna dikkat edin; eğer uygulama bu değişkenler için farklı isimler kullandıysa, bunu düzeltin.</p>
<p>Biraz garip olduğu için tekrarlayalım.  Kodunuz şimdi şöyle görünmelidir:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">return_type</span>
<span class="nf">your_function_impl</span><span class="p">(...)</span>
<span class="cm">/*[clinic end generated code: checksum=...]*/</span>
<span class="p">{</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Argüman Kliniği sağlama toplamı satırını ve hemen üstünde fonksiyon prototipini oluşturdu.  Fonksiyonun açılış (ve kapanış) küme parantezlerini ve içindeki uygulamayı yazmalısınız.</p>
<p>Örnek:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module _pickle</span>
<span class="cm">class _pickle.Pickler &quot;PicklerObject *&quot; &quot;&amp;Pickler_Type&quot;</span>
<span class="cm">[clinic start generated code]*/</span>
<span class="cm">/*[clinic end generated code: checksum=da39a3ee5e6b4b0d3255bfef95601890afd80709]*/</span>

<span class="cm">/*[clinic input]</span>
<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">    obj: &#39;O&#39;</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>

<span class="n">PyDoc_STRVAR</span><span class="p">(</span><span class="n">__pickle_Pickler_dump__doc__</span><span class="p">,</span>
<span class="s">&quot;Write a pickled representation of obj to the open file.</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="p">...</span>
<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="n">_pickle_Pickler_dump_impl</span><span class="p">(</span><span class="n">PicklerObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="cm">/*[clinic end generated code: checksum=3bd30745bf206a48f8b576a1da3d90f55a0a4187]*/</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Check whether the Pickler was initialized correctly (issue3664).</span>
<span class="cm">       Developers often forget to call __init__() in their subclasses, which</span>
<span class="cm">       would trigger a segfault without this check. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">write</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PicklingError</span><span class="p">,</span>
<span class="w">                     </span><span class="s">&quot;Pickler.__init__() was not called by %s.__init__()&quot;</span><span class="p">,</span>
<span class="w">                     </span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_name</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_Pickler_ClearBuffer</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="p">...</span>
</pre></div>
</div>
</li>
<li><p>Bu fonksiyon için <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> yapısına sahip makroyu hatırlıyor musunuz?  Bu fonksiyon için mevcut <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> yapısını bulun ve makroya bir referans ile değiştirin.  (Yerleşik modül kapsamındaysa, bu muhtemelen dosyanın sonuna çok yakın olacaktır; yerleşik bir sınıf yöntemiyse, bu muhtemelen uygulamanın altında ancak nispeten yakınında olacaktır)</p>
<p>Makronun gövdesinin sonda bir virgül içerdiğine dikkat edin.  Bu nedenle, mevcut statik <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> yapısını makro ile değiştirdiğinizde, <em>sonuna virgül eklemeyin</em>.</p>
<p>Örnek:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">PyMethodDef</span><span class="w"> </span><span class="n">Pickler_methods</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">__PICKLE_PICKLER_DUMP_METHODDEF</span>
<span class="w">    </span><span class="n">__PICKLE_PICKLER_CLEAR_MEMO_METHODDEF</span>
<span class="w">    </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">}</span><span class="w">                </span><span class="cm">/* sentinel */</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p>Derleyin, ardından regresyon testi paketinin ilgili bölümlerini çalıştırın. Bu değişiklik herhangi bir yeni derleme zamanı uyarısı veya hatası getirmemeli ve Python’un davranışında dışarıdan görülebilir bir değişiklik olmamalıdır.</p>
<p>Tek bir fark dışında: fonksiyonunuz üzerinde çalıştırılan <code class="docutils literal notranslate"><span class="pre">inspect.signature()</span></code> artık geçerli bir imza sağlamalıdır!</p>
<p>Tebrikler, ilk fonksiyonunuzu Argüman Kliniği ile çalışmak üzere taşıdınız!</p>
</li>
</ol>
</section>
<section id="advanced-topics">
<h2>İleri Düzey Konular<a class="headerlink" href="#advanced-topics" title="Permalink to this heading">¶</a></h2>
<p>Argüman Kliniği ile çalışma konusunda biraz deneyim kazandığınıza göre, bazı ileri düzey konuların zamanı geldi.</p>
<section id="symbolic-default-values">
<h3>Sembolik varsayılan değerler<a class="headerlink" href="#symbolic-default-values" title="Permalink to this heading">¶</a></h3>
<p>Bir parametre için sağladığınız varsayılan değer rastgele bir ifade olamaz.  Şu anda aşağıdakiler açıkça desteklenmektedir:</p>
<ul class="simple">
<li><p>Sayısal sabitler (integer ve float)</p></li>
<li><p>Dize sabitleri</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code> ve <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
<li><p>Modülün adıyla başlaması gereken <code class="docutils literal notranslate"><span class="pre">sys.maxsize</span></code> gibi basit sembolik sabitler</p></li>
</ul>
<p>(Gelecekte, <code class="docutils literal notranslate"><span class="pre">CONSTANT</span> <span class="pre">-</span> <span class="pre">1</span></code> gibi tam ifadelere izin vermek için bunun daha da ayrıntılı hale getirilmesi gerekebilir.)</p>
</section>
<section id="renaming-the-c-functions-and-variables-generated-by-argument-clinic">
<h3>Argüman Kliniği tarafından oluşturulan C işlevlerini ve değişkenlerini yeniden adlandırma<a class="headerlink" href="#renaming-the-c-functions-and-variables-generated-by-argument-clinic" title="Permalink to this heading">¶</a></h3>
<p>Argüman Kliniği sizin için ürettiği fonksiyonlara otomatik olarak isim verir. Bazen, oluşturulan ad mevcut bir C işlevinin adıyla çakışırsa bu bir soruna neden olabilir.  Bunun kolay bir çözümü vardır: C fonksiyonları için kullanılan isimleri geçersiz kılın.  Fonksiyon bildirim satırınıza <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code> anahtar sözcüğünü ve ardından kullanmak istediğiniz fonksiyon adını eklemeniz yeterlidir. Argument Clinic, temel (oluşturulan) işlev için bu işlev adını kullanacak, ardından sonuna <code class="docutils literal notranslate"><span class="pre">&quot;_impl&quot;</span></code> ekleyecek ve impl işlevinin adı için bunu kullanacaktır.</p>
<p>Örneğin, <code class="docutils literal notranslate"><span class="pre">pickle.Pickler.dump</span></code> için oluşturulan C fonksiyon adlarını yeniden adlandırmak istersek, şöyle görünecektir:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">pickle.Pickler.dump as pickler_dumper</span>

<span class="cm">...</span>
</pre></div>
</div>
<p>Temel işlev artık <code class="docutils literal notranslate"><span class="pre">pickler_dumper()</span></code> olarak adlandırılacak ve impl işlevi artık <code class="docutils literal notranslate"><span class="pre">pickler_dumper_impl()</span></code> olarak adlandırılacaktır.</p>
<p>Benzer şekilde, bir parametreye belirli bir Python adı vermek istediğinizde bir sorunla karşılaşabilirsiniz, ancak bu ad C’de uygun olmayabilir. Argument Clinic, aynı <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code> sözdizimini kullanarak bir parametreye Python’da ve C’de farklı adlar vermenize olanak tanır:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">pickle.Pickler.dump</span>

<span class="cm">    obj: object</span>
<span class="cm">    file as file_obj: object</span>
<span class="cm">    protocol: object = NULL</span>
<span class="cm">    *</span>
<span class="cm">    fix_imports: bool = True</span>
</pre></div>
</div>
<p>Burada, Python’da kullanılan isim (imzada ve <code class="docutils literal notranslate"><span class="pre">keywords</span></code> dizisinde) <code class="docutils literal notranslate"><span class="pre">file</span></code> olacaktır, ancak C değişkeni <code class="docutils literal notranslate"><span class="pre">file_obj</span></code> olarak adlandırılacaktır.</p>
<p>Bunu <code class="docutils literal notranslate"><span class="pre">self</span></code> parametresini yeniden adlandırmak için de kullanabilirsiniz!</p>
</section>
<section id="converting-functions-using-pyarg-unpacktuple">
<h3>PyArg_UnpackTuple kullanarak fonksiyonları dönüştürme<a class="headerlink" href="#converting-functions-using-pyarg-unpacktuple" title="Permalink to this heading">¶</a></h3>
<p>Argümanlarını <a class="reference internal" href="../c-api/arg.html#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a> ile ayrıştıran bir fonksiyonu dönüştürmek için, her birini bir <code class="docutils literal notranslate"><span class="pre">object</span></code> olarak belirterek tüm argümanları yazmanız yeterlidir.  Türü uygun şekilde dökmek için <code class="docutils literal notranslate"><span class="pre">type</span></code> argümanını belirtebilirsiniz.  Tüm argümanlar sadece konumsal olarak işaretlenmelidir (son argümandan sonra kendi başına bir satıra <code class="docutils literal notranslate"><span class="pre">/</span></code> ekleyin).</p>
<p>Şu anda oluşturulan kod <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> kullanacaktır, ancak bu yakında değişecektir.</p>
</section>
<section id="optional-groups">
<h3>İsteğe Bağlı Gruplar<a class="headerlink" href="#optional-groups" title="Permalink to this heading">¶</a></h3>
<p>Bazı eski fonksiyonların argümanlarını ayrıştırmak için zor bir yaklaşımı vardır: konumsal argümanların sayısını sayarlar, ardından kaç tane konumsal argüman olduğuna bağlı olarak birkaç farklı <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> çağrısından birini çağırmak için bir <code class="docutils literal notranslate"><span class="pre">switch</span></code> deyimi kullanırlar.  (Bu fonksiyonlar sadece anahtar kelime argümanlarını kabul edemez.) Bu yaklaşım <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> oluşturulmadan önce isteğe bağlı argümanları simüle etmek için kullanılıyordu.</p>
<p>Bu yaklaşımı kullanan fonksiyonlar genellikle <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>, isteğe bağlı argümanlar ve varsayılan değerleri kullanacak şekilde dönüştürülebilse de, bu her zaman mümkün değildir.  Bu eski fonksiyonlardan bazıları <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> fonksiyonunun doğrudan desteklemediği davranışlara sahiptir. En bariz örnek, gerekli argümanının <em>sol</em> tarafında isteğe bağlı bir argümana sahip olan yerleşik <code class="docutils literal notranslate"><span class="pre">range()</span></code> fonksiyonudur! Diğer bir örnek ise her zaman birlikte belirtilmesi gereken iki argümandan oluşan bir gruba sahip olan <code class="docutils literal notranslate"><span class="pre">curses.window.addch()</span></code> fonksiyonudur.  (Argümanlar <code class="docutils literal notranslate"><span class="pre">x</span></code> ve <code class="docutils literal notranslate"><span class="pre">y</span></code> olarak adlandırılır; fonksiyonu <code class="docutils literal notranslate"><span class="pre">x</span></code> değerini girerek çağırırsanız, <code class="docutils literal notranslate"><span class="pre">y</span></code> değerini de girmeniz gerekir ve <code class="docutils literal notranslate"><span class="pre">x</span></code> değerini girmezseniz <code class="docutils literal notranslate"><span class="pre">y</span></code> değerini de giremezsiniz)</p>
<p>Her durumda, Argüman Kliniği’nin amacı, anlamlarını değiştirmeden mevcut tüm CPython yerleşik bileşenleri için argüman ayrıştırmayı desteklemektir. Bu nedenle Argüman Kliniği <em>isteğe bağlı gruplar</em> olarak adlandırılan bu alternatif ayrıştırma yaklaşımını destekler. İsteğe bağlı gruplar, hepsi birlikte geçirilmesi gereken argüman gruplarıdır. Gerekli argümanların sağında veya solunda olabilirler.  Yalnızca <em>konumsal</em> parametrelerle kullanılabilirler.</p>
<div class="admonition note">
<p class="admonition-title">Not</p>
<p>İsteğe bağlı gruplar <em>sadece</em> <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>’a birden fazla çağrı yapan fonksiyonları dönüştürürken kullanılmak üzere tasarlanmıştır! Argümanları ayrıştırmak için <em>herhangi</em> bir başka yaklaşım kullanan fonksiyonlar <em>neredeyse hiçbir zaman</em> isteğe bağlı gruplar kullanılarak Argüman Kliniğine dönüştürülmemelidir.  İsteğe bağlı gruplar kullanan fonksiyonlar şu anda Python’da doğru imzalara sahip olamaz, çünkü Python bu kavramı anlamıyor.  Lütfen mümkün olan her yerde isteğe bağlı grupları kullanmaktan kaçının.</p>
</div>
<p>İsteğe bağlı bir grup belirtmek için, birlikte gruplamak istediğiniz parametrelerden önce tek başına bir satıra <code class="docutils literal notranslate"><span class="pre">[</span></code> ve bu parametrelerden sonra tek başına bir satıra <code class="docutils literal notranslate"><span class="pre">]</span></code> ekleyin.  Örnek olarak, <code class="docutils literal notranslate"><span class="pre">curses.window.addch</span></code> ilk iki parametreyi ve son parametreyi isteğe bağlı yapmak için isteğe bağlı grupları nasıl kullanır:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>

<span class="cm">curses.window.addch</span>

<span class="cm">    [</span>
<span class="cm">    x: int</span>
<span class="cm">      X-coordinate.</span>
<span class="cm">    y: int</span>
<span class="cm">      Y-coordinate.</span>
<span class="cm">    ]</span>

<span class="cm">    ch: object</span>
<span class="cm">      Character to add.</span>

<span class="cm">    [</span>
<span class="cm">    attr: long</span>
<span class="cm">      Attributes for the character.</span>
<span class="cm">    ]</span>
<span class="cm">    /</span>

<span class="cm">...</span>
</pre></div>
</div>
<p>Notlar:</p>
<ul class="simple">
<li><p>Her isteğe bağlı grup için, grubu temsil eden impl fonksiyonuna bir ek parametre aktarılacaktır.  Parametre <code class="docutils literal notranslate"><span class="pre">group_{direction}_{number}</span></code> adında bir int olacaktır; burada <code class="docutils literal notranslate"><span class="pre">{direction}</span></code> grubun gerekli parametrelerden önce veya sonra olmasına bağlı olarak <code class="docutils literal notranslate"><span class="pre">right</span></code> veya <code class="docutils literal notranslate"><span class="pre">left</span></code> şeklindedir ve <code class="docutils literal notranslate"><span class="pre">{number}</span></code> grubun gerekli parametrelerden ne kadar uzakta olduğunu gösteren monoton olarak artan bir sayıdır (1’den başlayarak).  impl çağrıldığında, bu parametre, bu grup kullanılmamışsa sıfıra, bu grup kullanılmışsa sıfır olmayana ayarlanacaktır. (Kullanılmış veya kullanılmamış derken, parametrelerin bu çağrıda argüman alıp almadığını kastediyorum.)</p></li>
<li><p>Gerekli argümanlar yoksa, isteğe bağlı gruplar gerekli argümanların sağındaymış gibi davranacaktır.</p></li>
<li><p>Belirsizlik durumunda, argüman ayrıştırma kodu soldaki parametreleri (gerekli parametrelerden önce) tercih eder.</p></li>
<li><p>İsteğe bağlı gruplar yalnızca konumsal parametreler içerebilir.</p></li>
<li><p>İsteğe bağlı gruplar <em>sadece</em> eski kod için tasarlanmıştır.  Lütfen yeni kod için isteğe bağlı grupları kullanmayın.</p></li>
</ul>
</section>
<section id="using-real-argument-clinic-converters-instead-of-legacy-converters">
<h3>“Eski dönüştürücüler” yerine gerçek Argüman Kliniği dönüştürücülerinin kullanılması<a class="headerlink" href="#using-real-argument-clinic-converters-instead-of-legacy-converters" title="Permalink to this heading">¶</a></h3>
<p>Zamandan tasarruf etmek ve Argüman Kliniğine ilk portunuzu gerçekleştirmek için ne kadar çok şey öğrenmeniz gerektiğini en aza indirmek için, yukarıdaki kılavuz size “eski dönüştürücüleri” kullanmanızı söyler.  “Eski dönüştürücüler”, mevcut kodun Argüman Kliniği’ne taşınmasını kolaylaştırmak için tasarlanmış bir kolaylıktır.  Ve açık olmak gerekirse, Python 3.4 için kod taşırken kullanımları kabul edilebilir.</p>
<p>Ancak, uzun vadede muhtemelen tüm bloklarımızın Argüman Kliniği’nin dönüştürücüler için gerçek sözdizimini kullanmasını istiyoruz.  Neden mi?  Birkaç nedeni var:</p>
<ul class="simple">
<li><p>Uygun dönüştürücülerin okunması çok daha kolay ve amaçları daha nettir.</p></li>
<li><p>“Eski dönüştürücüler” olarak desteklenmeyen bazı biçim birimleri vardır, çünkü bunlar argüman gerektirir ve eski dönüştürücü sözdizimi argüman belirtmeyi desteklemez.</p></li>
<li><p>Gelecekte <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>’ın desteklediğiyle sınırlı olmayan yeni bir argüman ayrıştırma kütüphanemiz olabilir; bu esneklik eski dönüştürücüleri kullanan parametreler için mevcut olmayacaktır.</p></li>
</ul>
<p>Bu nedenle, biraz fazladan çaba harcamaktan çekinmiyorsanız, lütfen eski dönüştürücüler yerine normal dönüştürücüleri kullanın.</p>
<p>Özetle, Argüman Kliniği (eski olmayan) dönüştürücüler için sözdizimi bir Python işlev çağrısı gibi görünür.  Ancak, fonksiyon için açık bir argüman yoksa (tüm fonksiyonlar varsayılan değerlerini alır), parantezleri atlayabilirsiniz.  Böylece <code class="docutils literal notranslate"><span class="pre">bool</span></code> ve <code class="docutils literal notranslate"><span class="pre">bool()</span></code> tamamen aynı dönüştürücülerdir.</p>
<p>Argüman Kliniği dönüştürücülerinin tüm bağımsız değişkenleri yalnızca anahtar sözcüktür. Tüm Argüman Kliniği dönüştürücüleri aşağıdaki bağımsız değişkenleri kabul eder:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">c_default</span></code></dt><dd><p>C’de tanımlandığında bu parametre için varsayılan değer. Özellikle, bu “parse fonksiyonu” içinde bildirilen değişken için başlatıcı olacaktır.  Bunun nasıl kullanılacağını öğrenmek için <a class="reference internal" href="#default-values"><span class="std std-ref">varsayılan değerler</span></a> bölümüne bakınız. Bir dize olarak belirtilir.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">annotation</span></code></dt><dd><p>Bu parametre için ek açıklama değeri.  Şu anda desteklenmemektedir, çünkü <span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a> Python kütüphanesinin ek açıklamaları kullanamayacağını belirtmektedir.</p>
</dd>
</dl>
</div></blockquote>
<p>Buna ek olarak, bazı dönüştürücüler ek bağımsız değişkenler kabul eder.  İşte anlamlarıyla birlikte bu bağımsız değişkenlerin bir listesi:</p>
<blockquote>
<div><dl>
<dt><code class="docutils literal notranslate"><span class="pre">accept</span></code></dt><dd><p>Bir Python türleri (ve muhtemelen sözde türler) kümesi; bu, izin verilen Python argümanını bu türlerin değerleriyle sınırlar. (Bu genel amaçlı bir olanak değildir; kural olarak yalnızca eski dönüştürücü tablosunda gösterilen belirli tür listelerini destekler).</p>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code> kabul etmek için bu kümeye <code class="docutils literal notranslate"><span class="pre">NoneType</span></code> ekleyin.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bitwise</span></code></dt><dd><p>Yalnızca işaretsiz tamsayılar için desteklenir.  Bu Python argümanının doğal tamsayı değeri, negatif değerler için bile herhangi bir aralık kontrolü yapılmadan parametreye yazılacaktır.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">converter</span></code></dt><dd><p>Sadece <code class="docutils literal notranslate"><span class="pre">object</span></code> dönüştürücü tarafından desteklenir.  Bu nesneyi yerel bir türe dönüştürmek için kullanılacak <a class="reference internal" href="../c-api/arg.html#o-ampersand"><span class="std std-ref">C “converter function”</span></a> adını belirtir.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">encoding</span></code></dt><dd><p>Yalnızca dizeler için desteklenir.  Bu dizeyi bir Python str (Unicode) değerinden bir C <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> değerine dönüştürürken kullanılacak kodlamayı belirtir.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">subclass_of</span></code></dt><dd><p>Yalnızca <code class="docutils literal notranslate"><span class="pre">object</span></code> dönüştürücü için desteklenir.  Python değerinin C’de ifade edildiği gibi bir Python türünün alt sınıfı olmasını gerektirir.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Sadece <code class="docutils literal notranslate"><span class="pre">object</span></code> ve <code class="docutils literal notranslate"><span class="pre">self</span></code> dönüştürücüleri için desteklenir.  Değişkeni bildirmek için kullanılacak C türünü belirtir.  Varsayılan değer <code class="docutils literal notranslate"><span class="pre">&quot;PyObject</span> <span class="pre">*&quot;</span></code> şeklindedir.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">zeroes</span></code></dt><dd><p>Yalnızca dizeler için desteklenir.  Eğer true ise, değerin içinde gömülü NUL baytlarına (<code class="docutils literal notranslate"><span class="pre">'\\0'</span></code>) izin verilir.  Dizenin uzunluğu impl fonksiyonuna, dize parametresinden hemen sonra, <code class="docutils literal notranslate"><span class="pre">&lt;parameter_name&gt;_length</span></code> adlı bir parametre olarak aktarılır.</p>
</dd>
</dl>
</div></blockquote>
<p>Lütfen her olası argüman kombinasyonunun çalışmayacağını unutmayın. Genellikle bu argümanlar belirli davranışlara sahip belirli <code class="docutils literal notranslate"><span class="pre">PyArg_ParseTuple</span></code> <em>format birimleri</em> tarafından uygulanır.  Örneğin, şu anda <code class="docutils literal notranslate"><span class="pre">bitwise=True</span></code> belirtmeden <code class="docutils literal notranslate"><span class="pre">unsigned_short</span></code> çağıramazsınız. Bunun işe yarayacağını düşünmek tamamen mantıklı olsa da, bu anlamlar mevcut herhangi bir biçim birimiyle eşleşmez.  Bu yüzden Argüman Kliniği bunu desteklemez.  (Ya da, en azından, henüz değil.)</p>
<p>Aşağıda, eski dönüştürücülerin gerçek Argüman Kliniği dönüştürücülerine eşlenmesini gösteren bir tablo bulunmaktadır.  Solda eski dönüştürücü, sağda ise onu değiştireceğiniz metin yer almaktadır.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'B'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_char(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'b'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_char</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'c'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">char</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'C'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int(accept={str})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'d'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">double</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'D'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_complex</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'es'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding')</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'es#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding',</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'et'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding',</span> <span class="pre">accept={bytes,</span> <span class="pre">bytearray,</span> <span class="pre">str})</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'et#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(encoding='name_of_encoding',</span> <span class="pre">accept={bytes,</span> <span class="pre">bytearray,</span> <span class="pre">str},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'f'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'h'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">short</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'H'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_short(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'i'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'I'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_int(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'k'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_long(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'K'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned_long_long(bitwise=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'l'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">long</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'L'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'n'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'O'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">object</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'O!'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">object(subclass_of='&amp;PySomething_Type')</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'O&amp;'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">object(converter='name_of_c_function')</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'p'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'S'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyBytesObject</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'s'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'s#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(zeroes=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'s*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer(accept={buffer,</span> <span class="pre">str})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'U'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unicode</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'u'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'u#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE(zeroes=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'w*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer(accept={rwbuffer})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'Y'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PyByteArrayObject</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'y'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={bytes})</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'y#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={robuffer},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'y*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'Z'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE(accept={str,</span> <span class="pre">NoneType})</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'Z#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_UNICODE(accept={str,</span> <span class="pre">NoneType},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'z'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={str,</span> <span class="pre">NoneType})</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'z#'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str(accept={str,</span> <span class="pre">NoneType},</span> <span class="pre">zeroes=True)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'z*'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Py_buffer(accept={buffer,</span> <span class="pre">str,</span> <span class="pre">NoneType})</span></code></p></td>
</tr>
</tbody>
</table>
<p>Örnek olarak, uygun dönüştürücüyü kullanan <code class="docutils literal notranslate"><span class="pre">pickle.Pickler.dump</span></code> örneğimiz:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">pickle.Pickler.dump</span>

<span class="cm">    obj: object</span>
<span class="cm">        The object to be pickled.</span>
<span class="cm">    /</span>

<span class="cm">Write a pickled representation of obj to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>Gerçek dönüştürücülerin bir avantajı, eski dönüştürücülere göre daha esnek olmalarıdır.  Örneğin, <code class="docutils literal notranslate"><span class="pre">unsigned_int</span></code> dönüştürücüsü (ve tüm <code class="docutils literal notranslate"><span class="pre">unsigned_</span></code> dönüştürücüleri) <code class="docutils literal notranslate"><span class="pre">bitwise=True</span></code> olmadan belirtilebilir.  Varsayılan davranışları değer üzerinde aralık denetimi yapar ve negatif sayıları kabul etmezler.  Bunu eski bir dönüştürücü ile yapamazsınız!</p>
<p>Argüman Kliniği size mevcut tüm dönüştürücüleri gösterecektir.  Her dönüştürücü için, kabul ettiği tüm parametreleri ve her parametre için varsayılan değeri gösterecektir. Tam listeyi görmek için <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span> <span class="pre">--converters</span></code> komutunu çalıştırmanız yeterlidir.</p>
</section>
<section id="py-buffer">
<h3>Py_buffer<a class="headerlink" href="#py-buffer" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Py_buffer</span></code> dönüştürücüsünü (veya <code class="docutils literal notranslate"><span class="pre">'s*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'w*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'*y'</span></code> veya <code class="docutils literal notranslate"><span class="pre">'z*'</span></code> eski dönüştürücülerini) kullanırken, sağlanan tampon üzerinde <a class="reference internal" href="../c-api/buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a> çağrısı yapmamanız gerekir. Argument Clinic bunu sizin için yapan kodu üretir (ayrıştırma işlevinde).</p>
</section>
<section id="advanced-converters">
<h3>Gelişmiş dönüştürücüler<a class="headerlink" href="#advanced-converters" title="Permalink to this heading">¶</a></h3>
<p>İlk seferinizde ileri düzey oldukları için atladığınız format ünitelerini hatırlıyor musunuz?  İşte onları da nasıl halledeceğiniz.</p>
<p>İşin püf noktası, tüm bu format birimlerinin argüman almasıdır - ya dönüştürme fonksiyonları, ya tipler ya da kodlama belirten dizeler. (Ancak “eski dönüştürücüler” argümanları desteklemez.  Bu yüzden ilk fonksiyonunuz için onları atladık).  Biçim birimine belirttiğiniz argüman artık dönüştürücünün bir argümanıdır; bu argüman ya <code class="docutils literal notranslate"><span class="pre">converter</span></code> (<code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> için), <code class="docutils literal notranslate"><span class="pre">subclass_of</span></code> (<code class="docutils literal notranslate"><span class="pre">O!</span></code> için) ya da <code class="docutils literal notranslate"><span class="pre">encoding</span></code> (<code class="docutils literal notranslate"><span class="pre">e</span></code> ile başlayan tüm biçim birimleri için) şeklindedir.</p>
<p><code class="docutils literal notranslate"><span class="pre">subclass_of</span></code> kullanırken, <code class="docutils literal notranslate"><span class="pre">object()</span></code> için diğer özel bağımsız değişkeni de kullanmak isteyebilirsiniz: <code class="docutils literal notranslate"><span class="pre">type</span></code>, parametre için gerçekte kullanılan türü ayarlamanızı sağlar.  Örneğin, nesnenin <code class="docutils literal notranslate"><span class="pre">PyUnicode_Type</span></code> türünün bir alt sınıfı olduğundan emin olmak istiyorsanız, muhtemelen <code class="docutils literal notranslate"><span class="pre">object(type='PyUnicodeObject</span> <span class="pre">*',</span> <span class="pre">subclass_of='&amp;PyUnicode_Type')</span></code> dönüştürücüsünü kullanmak istersiniz.</p>
<p>Argüman Kliniği kullanımıyla ilgili olası bir sorun: <code class="docutils literal notranslate"><span class="pre">e</span></code> ile başlayan biçim birimleri için bazı olası esneklikleri ortadan kaldırır.  Elle bir <code class="docutils literal notranslate"><span class="pre">PyArg_Parse</span></code> çağrısı yazarken, teorik olarak <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>’a hangi kodlama dizgesini aktaracağınıza çalışma zamanında karar verebilirsiniz.   Ancak şimdi bu dizge Argüman Kliniği-önişleme zamanında sabit kodlanmalıdır.  Bu sınırlama kasıtlıdır; bu format birimini desteklemeyi çok daha kolay hale getirdi ve gelecekteki optimizasyonlara izin verebilir. Bu kısıtlama mantıksız görünmüyor; CPython’un kendisi, biçim birimleri <code class="docutils literal notranslate"><span class="pre">e</span></code> ile başlayan parametreler için her zaman statik sabit kodlu kodlama dizeleri geçirir.</p>
</section>
<section id="parameter-default-values">
<span id="default-values"></span><h3>Parametre varsayılan değerleri<a class="headerlink" href="#parameter-default-values" title="Permalink to this heading">¶</a></h3>
<p>Parametreler için varsayılan değerler bir dizi değerden herhangi biri olabilir. En basit haliyle string, int veya float değişmezleri olabilirler:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: str = &quot;abc&quot;
bar: int = 123
bat: float = 45.6
</pre></div>
</div>
<p>Python’un yerleşik sabitlerinden herhangi birini de kullanabilirler:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>yep:  bool = True
nope: bool = False
nada: object = None
</pre></div>
</div>
<p>Ayrıca <code class="docutils literal notranslate"><span class="pre">NULL</span></code> varsayılan değeri ve aşağıdaki bölümlerde belgelenen basit ifadeler için özel bir destek de vardır.</p>
</section>
<section id="the-null-default-value">
<h3>Varsayılan değer <code class="docutils literal notranslate"><span class="pre">NULL</span></code><a class="headerlink" href="#the-null-default-value" title="Permalink to this heading">¶</a></h3>
<p>Dize ve nesne parametreleri için, varsayılan olmadığını belirtmek için bunları <code class="docutils literal notranslate"><span class="pre">None</span></code> olarak ayarlayabilirsiniz.  Ancak bu, C değişkeninin <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> olarak başlatılacağı anlamına gelir.  Kolaylık olması açısından, sadece bu nedenle <code class="docutils literal notranslate"><span class="pre">NULL</span></code> adında özel bir değer vardır: Python’un bakış açısından varsayılan değer <code class="docutils literal notranslate"><span class="pre">None</span></code> gibi davranır, ancak C değişkeni <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ile başlatılır.</p>
</section>
<section id="expressions-specified-as-default-values">
<h3>Varsayılan değerler olarak belirtilen ifadeler<a class="headerlink" href="#expressions-specified-as-default-values" title="Permalink to this heading">¶</a></h3>
<p>Bir parametre için varsayılan değer, gerçek bir değerden daha fazlası olabilir. Matematik operatörlerini kullanan ve nesnelerdeki öznitelikleri arayan bütün bir ifade olabilir.  Ancak bu destek, bazı açık olmayan anlamlar nedeniyle tam olarak basit değildir.</p>
<p>Aşağıdaki örneği ele alalım:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: Py_ssize_t = sys.maxsize - 1
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sys.maxsize</span></code> farklı platformlarda farklı değerlere sahip olabilir.  Bu nedenle Argument Clinic bu ifadeyi yerel olarak değerlendiremez ve C’de sabit kodlayamaz. Bu nedenle varsayılanı, kullanıcı işlevin imzasını istediğinde çalışma zamanında değerlendirilecek şekilde saklar.</p>
<p>İfade değerlendirildiğinde hangi ad alanı kullanılabilir?  Yerleşik öğenin geldiği modül bağlamında değerlendirilir.  Dolayısıyla, modülünüzün “<code class="docutils literal notranslate"><span class="pre">max_widgets</span></code>” adlı bir niteliği varsa, bunu kullanabilirsiniz:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: Py_ssize_t = max_widgets
</pre></div>
</div>
<p>Eğer sembol mevcut modülde bulunamazsa, <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> içinde aramaya devam eder.  Örneğin <code class="docutils literal notranslate"><span class="pre">sys.maxsize</span></code> bu şekilde bulunabilir.  (Kullanıcının yorumlayıcısına hangi modülleri yükleyeceğini önceden bilemeyeceğiniz için, kendinizi Python’un kendisi tarafından önceden yüklenmiş modüllerle sınırlamak en iyisidir).</p>
<p>Varsayılan değerlerin yalnızca çalışma zamanında değerlendirilmesi, Argüman Kliniği’nin doğru eşdeğer C varsayılan değerini hesaplayamayacağı anlamına gelir.  Bu yüzden ona açıkça söylemeniz gerekir. Bir ifade kullandığınızda, dönüştürücüye <code class="docutils literal notranslate"><span class="pre">c_default</span></code> parametresini kullanarak C’deki eşdeğer ifadeyi de belirtmeniz gerekir:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>foo: Py_ssize_t(c_default=&quot;PY_SSIZE_T_MAX - 1&quot;) = sys.maxsize - 1
</pre></div>
</div>
<p>Başka bir komplikasyon: Argüman Kliniği, sağladığınız ifadenin geçerli olup olmadığını önceden bilemez.  Yasal göründüğünden emin olmak için ayrıştırır, ancak <em>gerçekten</em> bilemez.  Çalışma zamanında geçerli olacağı garanti edilen değerleri belirtmek için ifadeleri kullanırken çok dikkatli olmalısınız!</p>
<p>Son olarak, ifadelerin statik C değerleri olarak gösterilebilir olması gerektiğinden, yasal ifadeler üzerinde birçok kısıtlama vardır.  İşte kullanmanıza izin verilmeyen Python özelliklerinin bir listesi:</p>
<ul class="simple">
<li><p>Fonksiyon çağrıları.</p></li>
<li><p>Satır içi if ifadeleri (<code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">if</span> <span class="pre">foo</span> <span class="pre">else</span> <span class="pre">5</span></code>).</p></li>
<li><p>Otomatik dizi açma (<code class="docutils literal notranslate"><span class="pre">*[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>).</p></li>
<li><p>Liste/set/dict kavramaları ve üretici ifadeleri.</p></li>
<li><p>Tuple/list/set/dict değişmezleri.</p></li>
</ul>
</section>
<section id="using-a-return-converter">
<h3>Dönüş dönüştürücüsü kullanma<a class="headerlink" href="#using-a-return-converter" title="Permalink to this heading">¶</a></h3>
<p>Argüman Kliniği’nin sizin için oluşturduğu impl fonksiyonu varsayılan olarak <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code> döndürür. Ancak C fonksiyonunuz genellikle bir C tipini hesaplar, sonra son anda onu <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>’e dönüştürür.  Argüman Kliniği girdilerinizi Python türlerinden yerel C türlerine dönüştürür - neden dönüş değerinizi de yerel bir C türünden bir Python türüne dönüştürmesin?</p>
<p>“Dönüş dönüştürücüsü” de bunu yapar.  Bir C tipi döndürmek için impl fonksiyonunuzu değiştirir, ardından bu değeri uygun <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code>’e dönüştürmek için oluşturulan (impl olmayan) fonksiyona kod ekler.</p>
<p>Dönüş dönüştürücüleri için sözdizimi parametre dönüştürücülerine benzer. Dönüş dönüştürücüsünü fonksiyonun kendisindeki bir dönüş ek açıklaması gibi belirtirsiniz.  Dönüş dönüştürücüleri parametre dönüştürücüleriyle aynı şekilde davranır; argüman alırlar, argümanların tümü yalnızca anahtar sözcüktür ve varsayılan argümanlardan herhangi birini değiştirmiyorsanız parantezleri atlayabilirsiniz.</p>
<p>(Fonksiyonunuz için hem <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code> * hem de * return dönüştürücü kullanıyorsanız, <code class="docutils literal notranslate"><span class="pre">&quot;as&quot;</span></code> return dönüştürücüden önce gelmelidir.)</p>
<p>Geri dönüş dönüştürücülerini kullanırken ek bir karmaşıklık vardır: bir hata oluştuğunu nasıl belirtirsiniz?  Normalde, bir fonksiyon başarı için geçerli (<code class="docutils literal notranslate"><span class="pre">NULL</span></code> olmayan) bir işaretçi döndürür ve başarısızlık için <code class="docutils literal notranslate"><span class="pre">NULL</span></code> döndürür.  Ancak bir tamsayı dönüş dönüştürücüsü kullanırsanız, tüm tamsayılar geçerlidir.  Argüman Kliniği bir hatayı nasıl tespit edebilir?  Çözümü: her geri dönüş dönüştürücüsü örtük olarak bir hatayı gösteren özel bir değer arar.  Bu değeri döndürürseniz ve bir hata ayarlanmışsa (<code class="docutils literal notranslate"><span class="pre">PyErr_Occurred()</span></code> doğru bir değer döndürür), oluşturulan kod hatayı yayacaktır.  Aksi takdirde, döndürdüğünüz değeri normal şekilde kodlayacaktır.</p>
<p>Şu anda Argüman Kliniği yalnızca birkaç dönüş dönüştürücüsünü desteklemektedir:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bool
int
unsigned int
long
unsigned int
size_t
Py_ssize_t
float
double
DecodeFSDefault
</pre></div>
</div>
<p>Bunların hiçbiri parametre almaz.  İlk üçü için, hatayı belirtmek üzere -1 döndürülür.  <code class="docutils literal notranslate"><span class="pre">DecodeFSDefault</span></code> için dönüş türü <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code>’dır; bir hata belirtmek için <code class="docutils literal notranslate"><span class="pre">NULL</span></code> işaretçisi döndürür.</p>
<p>(Ayrıca, <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> referans sayısını artırmak zorunda kalmadan, başarı durumunda <code class="docutils literal notranslate"><span class="pre">Py_None</span></code> veya başarısızlık durumunda <code class="docutils literal notranslate"><span class="pre">NULL</span></code> döndürmenizi sağlayan deneysel bir <code class="docutils literal notranslate"><span class="pre">NoneType</span></code> dönüştürücü de vardır.  Kullanmaya değecek kadar netlik kattığından emin değilim.)</p>
<p>Argüman Kliniği’nin desteklediği tüm dönüş dönüştürücülerini parametreleriyle (varsa) birlikte görmek için, tam liste için <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span> <span class="pre">--converters</span></code> komutunu çalıştırmanız yeterlidir.</p>
</section>
<section id="cloning-existing-functions">
<h3>Mevcut fonksiyonları klonlama<a class="headerlink" href="#cloning-existing-functions" title="Permalink to this heading">¶</a></h3>
<p>Birbirine benzeyen çok sayıda fonksiyonunuz varsa, Kliniğin “clone” özelliğini kullanabilirsiniz.  Mevcut bir işlevi klonladığınızda, yeniden kullanırsınız:</p>
<ul class="simple">
<li><p>parametreleri, dahil olmak üzere</p>
<ul>
<li><p>isimleri,</p></li>
<li><p>dönüştürücüleri, tüm parametrelerle birlikte,</p></li>
<li><p>varsayılan değerleri,</p></li>
<li><p>parametre başına dokümanları,</p></li>
<li><p>türleri* (yalnızca konumsal, konumsal veya anahtar sözcük ya da yalnızca anahtar sözcük olup olmadıkları) ve</p></li>
</ul>
</li>
<li><p>dönüş dönüştürücüsü.</p></li>
</ul>
<p>Orijinal fonksiyondan kopyalanmayan tek şey onun docstring’idir; sözdizimi yeni bir docstring belirtmenize izin verir.</p>
<p>Bir fonksiyonu klonlamak için sözdizimi şöyledir:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">module.class.new_function [as c_basename] = module.class.existing_function</span>

<span class="cm">Docstring for new_function goes here.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>(Fonksiyonlar farklı modüllerde veya sınıflarda olabilir.  Örnekte <code class="docutils literal notranslate"><span class="pre">module.class</span></code> yazdım, sadece <em>her iki</em> fonksiyon için de tam yolu kullanmanız gerektiğini göstermek için.)</p>
<p>Üzgünüz, bir fonksiyonu kısmen klonlamak veya bir fonksiyonu klonladıktan sonra değiştirmek için bir sözdizimi yoktur.  Klonlama bir ya hep ya hiç önermesidir.</p>
<p>Ayrıca, klonladığınız fonksiyonun mevcut dosyada daha önce tanımlanmış olması gerekir.</p>
</section>
<section id="calling-python-code">
<h3>Python kodunu çağırma<a class="headerlink" href="#calling-python-code" title="Permalink to this heading">¶</a></h3>
<p>İleri düzey konuların geri kalanı, C dosyanızın içinde yaşayan ve Argüman Kliniği’nin çalışma zamanı durumunu değiştiren Python kodu yazmanızı gerektirir.  Bu basittir: sadece bir Python bloğu tanımlarsınız.</p>
<p>Bir Python bloğu, Argüman Kliniği işlev bloğundan farklı sınırlayıcı satırlar kullanır.  Şöyle görünür:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>
<span class="cm"># python code goes here</span>
<span class="cm">[python start generated code]*/</span>
</pre></div>
</div>
<p>Python bloğunun içindeki tüm kod ayrıştırıldığı anda çalıştırılır.  Blok içinde stdout’a yazılan tüm metin, bloktan sonra “çıktı “ya yönlendirilir.</p>
<p>Örnek olarak, işte C koduna statik bir tamsayı değişkeni ekleyen bir Python bloğu:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>
<span class="cm">print(&#39;static int __ignored_unused_variable__ = 0;&#39;)</span>
<span class="cm">[python start generated code]*/</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__ignored_unused_variable__</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="cm">/*[python checksum:...]*/</span>
</pre></div>
</div>
</section>
<section id="using-a-self-converter">
<h3>“Kendi kendine dönüştürücü” kullanma<a class="headerlink" href="#using-a-self-converter" title="Permalink to this heading">¶</a></h3>
<p>Argüman Kliniği, varsayılan bir dönüştürücü kullanarak sizin için otomatik olarak bir “self” parametresi ekler.  Bu parametrenin <code class="docutils literal notranslate"><span class="pre">type</span></code> değerini otomatik olarak, türü bildirirken belirttiğiniz “bir örneğe işaretçi” olarak ayarlar.  Ancak, Argüman Kliniği’nin dönüştürücüsünü geçersiz kılabilir ve kendiniz bir dönüştürücü belirleyebilirsiniz. Sadece kendi <code class="docutils literal notranslate"><span class="pre">self</span></code> parametrenizi bir bloktaki ilk parametre olarak ekleyin ve dönüştürücüsünün <code class="docutils literal notranslate"><span class="pre">self_converter</span></code> veya onun bir alt sınıfının bir örneği olduğundan emin olun.</p>
<p>Ne anlamı var?  Bu, <code class="docutils literal notranslate"><span class="pre">self</span></code> türünü geçersiz kılmanıza veya ona farklı bir varsayılan ad vermenize olanak tanır.</p>
<p><code class="docutils literal notranslate"><span class="pre">self</span></code> için döküm yapmak istediğiniz özel türü nasıl belirlersiniz? Eğer <code class="docutils literal notranslate"><span class="pre">self</span></code> için aynı tipe sahip sadece bir veya iki fonksiyonunuz varsa, kullanmak istediğiniz tipi <code class="docutils literal notranslate"><span class="pre">type</span></code> parametresi olarak girerek Argüman Kliniğinin mevcut <code class="docutils literal notranslate"><span class="pre">self</span></code> dönüştürücüsünü doğrudan kullanabilirsiniz:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>

<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">  self: self(type=&quot;PicklerObject *&quot;)</span>
<span class="cm">  obj: object</span>
<span class="cm">  /</span>

<span class="cm">Write a pickled representation of the given object to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>Öte yandan, <code class="docutils literal notranslate"><span class="pre">self</span></code> için aynı türü kullanacak çok sayıda işleviniz varsa, en iyisi <code class="docutils literal notranslate"><span class="pre">self_converter</span></code> alt sınıfını kullanarak, ancak <code class="docutils literal notranslate"><span class="pre">type</span></code> üyesinin üzerine yazarak kendi dönüştürücünüzü oluşturmaktır:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>
<span class="cm">class PicklerObject_converter(self_converter):</span>
<span class="cm">    type = &quot;PicklerObject *&quot;</span>
<span class="cm">[python start generated code]*/</span>

<span class="cm">/*[clinic input]</span>

<span class="cm">_pickle.Pickler.dump</span>

<span class="cm">  self: PicklerObject</span>
<span class="cm">  obj: object</span>
<span class="cm">  /</span>

<span class="cm">Write a pickled representation of the given object to the open file.</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
</section>
<section id="using-a-defining-class-converter">
<h3>“Sınıf tanımlama” dönüştürücüsü kullanma<a class="headerlink" href="#using-a-defining-class-converter" title="Permalink to this heading">¶</a></h3>
<p>Argüman Kliniği, bir metodun tanımlayıcı sınıfına erişim sağlamayı kolaylaştırır. Bu, modül düzeyinde durum getirmesi gereken <a class="reference internal" href="../c-api/typeobj.html#heap-types"><span class="std std-ref">heap type</span></a> yöntemleri için kullanışlıdır.  Yeni bir heap tipini bir modül ile ilişkilendirmek için <a class="reference internal" href="../c-api/type.html#c.PyType_FromModuleAndSpec" title="PyType_FromModuleAndSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromModuleAndSpec()</span></code></a> kullanın.  Artık modül durumunu, örneğin bir modül yönteminden almak için tanımlayıcı sınıf üzerinde <a class="reference internal" href="../c-api/type.html#c.PyType_GetModuleState" title="PyType_GetModuleState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModuleState()</span></code></a> kullanabilirsiniz.</p>
<p><code class="docutils literal notranslate"><span class="pre">Modules/zlibmodule.c</span></code> den örnek.  İlk olarak, <code class="docutils literal notranslate"><span class="pre">defining_class</span></code> klinik girdisine eklenir:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">zlib.Compress.compress</span>

<span class="cm">  cls: defining_class</span>
<span class="cm">  data: Py_buffer</span>
<span class="cm">    Binary data to be compressed.</span>
<span class="cm">  /</span>
</pre></div>
</div>
<p>Argüman Kliniği aracını çalıştırdıktan sonra aşağıdaki fonksiyon imzası oluşturulur:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic start generated code]*/</span>
<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="n">zlib_Compress_compress_impl</span><span class="p">(</span><span class="n">compobject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">cls</span><span class="p">,</span>
<span class="w">                            </span><span class="n">Py_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="cm">/*[clinic end generated code: output=6731b3f0ff357ca6 input=04d00f65ab01d260]*/</span>
</pre></div>
</div>
<p>Aşağıdaki kod artık modül durumunu almak için <code class="docutils literal notranslate"><span class="pre">PyType_GetModuleState(cls)</span></code> kullanabilir:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">zlibstate</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyType_GetModuleState</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</pre></div>
</div>
<p>Bu dönüştürücüyü kullanan her yöntemin yalnızca bir argümanı olabilir ve bu argüman <code class="docutils literal notranslate"><span class="pre">self</span></code> öğesinden sonra veya <code class="docutils literal notranslate"><span class="pre">self</span></code> öğesi kullanılmamışsa ilk argüman olarak görünmelidir.  Argüman <code class="docutils literal notranslate"><span class="pre">PyTypeObject</span> <span class="pre">*</span></code> tipinde olacaktır.  Argüman <code class="docutils literal notranslate"><span class="pre">__text_signature__</span></code> içinde görünmeyecektir.</p>
<p><code class="docutils literal notranslate"><span class="pre">defining_class</span></code> dönüştürücüsü, <code class="docutils literal notranslate"><span class="pre">METH_METHOD</span></code> kuralını kullanamayan <code class="docutils literal notranslate"><span class="pre">__init__</span></code> ve <code class="docutils literal notranslate"><span class="pre">__new__</span></code> yöntemleriyle uyumlu değildir.</p>
<p>Slot metotları ile <code class="docutils literal notranslate"><span class="pre">defining_class</span></code> kullanmak mümkün değildir.  Bu tür yöntemlerden modül durumunu almak için, modülü aramak için <a class="reference internal" href="../c-api/type.html#c.PyType_GetModuleByDef" title="PyType_GetModuleByDef"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModuleByDef()</span></code></a> ve ardından modül durumunu almak için <a class="reference internal" href="../c-api/module.html#c.PyModule_GetState" title="PyModule_GetState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_GetState()</span></code></a> kullanın. <code class="docutils literal notranslate"><span class="pre">Modules/_threadmodule.c</span></code> içindeki <code class="docutils literal notranslate"><span class="pre">setattro</span></code> slot yönteminden örnek:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">local_setattro</span><span class="p">(</span><span class="n">localobject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyType_GetModuleByDef</span><span class="p">(</span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">thread_module</span><span class="p">);</span>
<span class="w">    </span><span class="n">thread_module_state</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_thread_state</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Bkz: <span class="target" id="index-5"></span><a class="pep reference external" href="https://peps.python.org/pep-0573/"><strong>PEP 573</strong></a>.</p>
</section>
<section id="writing-a-custom-converter">
<h3>Özel bir dönüştürücü yazma<a class="headerlink" href="#writing-a-custom-converter" title="Permalink to this heading">¶</a></h3>
<p>Önceki bölümde ima ettiğimiz gibi… kendi dönüştürücülerinizi yazabilirsiniz! Bir dönüştürücü basitçe <code class="docutils literal notranslate"><span class="pre">CConverter</span></code>’dan miras alan bir Python sınıfıdır. Özel bir dönüştürücünün ana amacı, <code class="docutils literal notranslate"><span class="pre">O&amp;</span></code> biçimini kullanan bir parametreniz varsa, bu parametreyi birim ayrıştırmak, bir <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> “dönüştürücü işlevi” çağırmak anlamına gelir.</p>
<p>Dönüştürücü sınıfınızın adı <code class="docutils literal notranslate"><span class="pre">*something*_converter</span></code> olmalıdır. İsim bu kurala uygunsa, dönüştürücü sınıfınız Argüman Kliniği’ne otomatik olarak kaydedilecektir; adı, <code class="docutils literal notranslate"><span class="pre">_converter</span></code> son eki çıkarılmış sınıfınızın adı olacaktır.  (Bu bir meta sınıf ile gerçekleştirilir.)</p>
<p><code class="docutils literal notranslate"><span class="pre">CConverter.__init__</span></code> alt sınıfını kullanmamalısınız.  Bunun yerine, bir <code class="docutils literal notranslate"><span class="pre">converter_init()</span></code> fonksiyonu yazmalısınız.  <code class="docutils literal notranslate"><span class="pre">converter_init()</span></code> her zaman bir <code class="docutils literal notranslate"><span class="pre">self</span></code> parametresi kabul eder; bundan sonra, tüm ek parametreler <em>mutlaka</em> yalnızca anahtar kelime olmalıdır.  Argüman Kliniği`nde dönüştürücüye aktarılan tüm argümanlar <code class="docutils literal notranslate"><span class="pre">converter_init()</span></code> fonksiyonunuza aktarılacaktır.</p>
<p>Alt sınıfınızda belirtmek isteyebileceğiniz bazı ek <code class="docutils literal notranslate"><span class="pre">CConverter</span></code> üyeleri vardır.  İşte mevcut liste:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Bu değişken için kullanılacak C türü. <code class="docutils literal notranslate"><span class="pre">type</span></code> türü belirten bir Python dizesi olmalıdır, örneğin <code class="docutils literal notranslate"><span class="pre">int</span></code>. Eğer bu bir gösterici tipiyse, tip dizesi <code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">*'</span></code> ile bitmelidir.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">default</span></code></dt><dd><p>Bir Python değeri olarak bu parametre için Python varsayılan değeri. Veya varsayılan değer yoksa <code class="docutils literal notranslate"><span class="pre">unspecified</span></code> sihirli değeri.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">py_default</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">default</span></code> Python kodunda görünmesi gerektiği gibi, bir string olarak. Veya varsayılan yoksa <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c_default</span></code></dt><dd><p>C kodunda görünmesi gerektiği gibi, bir dize olarak <code class="docutils literal notranslate"><span class="pre">default</span></code>. Veya varsayılan yoksa <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">c_ignored_default</span></code></dt><dd><p>Varsayılan bir değer olmadığında C değişkenini başlatmak için kullanılan varsayılan değerdir, ancak varsayılan bir değer belirtilmemesi “başlatılmamış değişken” uyarısına neden olabilir.  Bu durum, seçenek grupları kullanıldığında kolaylıkla meydana gelebilir; doğru yazılmış kod bu değeri hiçbir zaman kullanmayacak olsa da, değişken impl’ye aktarılır ve C derleyicisi başlatılmamış değerin “kullanımından” şikayet eder.  Bu değer her zaman boş olmayan bir dize olmalıdır.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">converter</span></code></dt><dd><p>C dönüştürücü işlevinin bir dize olarak adı.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">impl_by_reference</span></code></dt><dd><p>Boolean bir değer.  Eğer true ise, Argüman Kliniği değişkeni impl fonksiyonuna aktarırken değişkenin isminin önüne bir <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> ekler.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parse_by_reference</span></code></dt><dd><p>Boolean bir değer.  Eğer true ise, Argüman Kliniği <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> içine aktarırken değişkenin isminin önüne bir <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> ekleyecektir.</p>
</dd>
</dl>
<p>İşte <code class="docutils literal notranslate"><span class="pre">Modules/zlibmodule.c</span></code> adresinden özel bir dönüştürücünün en basit örneği:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[python input]</span>

<span class="cm">class ssize_t_converter(CConverter):</span>
<span class="cm">    type = &#39;Py_ssize_t&#39;</span>
<span class="cm">    converter = &#39;ssize_t_converter&#39;</span>

<span class="cm">[python start generated code]*/</span>
<span class="cm">/*[python end generated code: output=da39a3ee5e6b4b0d input=35521e4e733823c7]*/</span>
</pre></div>
</div>
<p>Bu blok Argüman Kliniğine <code class="docutils literal notranslate"><span class="pre">ssize_t</span></code> adında bir dönüştürücü ekler.  <code class="docutils literal notranslate"><span class="pre">ssize_t</span></code> olarak bildirilen parametreler <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> türünde bildirilecek ve <code class="docutils literal notranslate"><span class="pre">'O&amp;'</span></code> biçim birimi tarafından ayrıştırılacak ve <code class="docutils literal notranslate"><span class="pre">ssize_t_converter</span></code> dönüştürücü işlevini çağıracaktır.  <code class="docutils literal notranslate"><span class="pre">ssize_t</span></code> değişkenleri otomatik olarak varsayılan değerleri destekler.</p>
<p>Daha sofistike özel dönüştürücüler, başlatma ve temizleme işlemlerini gerçekleştirmek için özel C kodu ekleyebilir. CPython kaynak ağacında daha fazla özel dönüştürücü örneği görebilirsiniz; <code class="docutils literal notranslate"><span class="pre">CConverter</span></code> dizesi için C dosyalarını grepleyin.</p>
</section>
<section id="writing-a-custom-return-converter">
<h3>Özel bir dönüş dönüştürücü yazma<a class="headerlink" href="#writing-a-custom-return-converter" title="Permalink to this heading">¶</a></h3>
<p>Özel bir return dönüştürücü yazmak, özel bir dönüştürücü yazmaya çok benzer.  Biraz basit olması dışında, çünkü geri dönüş dönüştürücülerinin kendileri çok daha basittir.</p>
<p>Dönüş dönüştürücüleri <code class="docutils literal notranslate"><span class="pre">CReturnConverter</span></code> alt sınıfına sahip olmalıdır. Henüz yaygın olarak kullanılmadıkları için özel dönüş dönüştürücüleri için henüz bir örnek yoktur.  Kendi dönüş dönüştürücünüzü yazmak istiyorsanız, lütfen <code class="docutils literal notranslate"><span class="pre">Tools/clinic/clinic.py</span></code> dosyasını, özellikle <code class="docutils literal notranslate"><span class="pre">CReturnConverter</span></code> ve tüm alt sınıflarının uygulamasını okuyun.</p>
</section>
<section id="meth-o-and-meth-noargs">
<h3>METH_O ve METH_NOARGS<a class="headerlink" href="#meth-o-and-meth-noargs" title="Permalink to this heading">¶</a></h3>
<p>Bir fonksiyonu <code class="docutils literal notranslate"><span class="pre">METH_O</span></code> kullanarak dönüştürmek için, fonksiyonun tek argümanının <code class="docutils literal notranslate"><span class="pre">object</span></code> dönüştürücüsünü kullandığından emin olun ve argümanları sadece pozisyonel olarak işaretleyin:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*[clinic input]</span>
<span class="cm">meth_o_sample</span>

<span class="cm">     argument: object</span>
<span class="cm">     /</span>
<span class="cm">[clinic start generated code]*/</span>
</pre></div>
</div>
<p>Bir fonksiyonu <code class="docutils literal notranslate"><span class="pre">METH_NOARGS</span></code> kullanarak dönüştürmek için herhangi bir argüman belirtmemeniz yeterlidir.</p>
<p>Yine de bir self dönüştürücü, bir return dönüştürücü kullanabilir ve <code class="docutils literal notranslate"><span class="pre">METH_O</span></code> için nesne dönüştürücüye bir <code class="docutils literal notranslate"><span class="pre">type</span></code> argümanı belirtebilirsiniz.</p>
</section>
<section id="tp-new-and-tp-init-functions">
<h3>tp_new ve tp_init fonksiyonları<a class="headerlink" href="#tp-new-and-tp-init-functions" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">tp_new</span></code> ve <code class="docutils literal notranslate"><span class="pre">tp_init</span></code> fonksiyonlarını dönüştürebilirsiniz.  Bunları uygun şekilde <code class="docutils literal notranslate"><span class="pre">__new__</span></code> veya <code class="docutils literal notranslate"><span class="pre">__init__</span></code> olarak adlandırmanız yeterlidir.  Notlar:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__new__</span></code> için oluşturulan işlev adı, varsayılan olarak olduğu gibi <code class="docutils literal notranslate"><span class="pre">__new__</span></code> ile bitmez.  Bu sadece geçerli bir C tanımlayıcısına dönüştürülmüş sınıf adıdır.</p></li>
<li><p>Bu fonksiyonlar için <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> <code class="docutils literal notranslate"><span class="pre">#define</span></code> oluşturulmaz.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__init__</span></code> fonksiyonları <code class="docutils literal notranslate"><span class="pre">PyObject</span> <span class="pre">*</span></code> değil <code class="docutils literal notranslate"><span class="pre">int</span></code> döndürür.</p></li>
<li><p>Doküman dizesini sınıf doküman dizesi olarak kullanın.</p></li>
<li><p>Her ne kadar <code class="docutils literal notranslate"><span class="pre">__new__</span></code> ve <code class="docutils literal notranslate"><span class="pre">__init__</span></code> fonksiyonları her zaman hem <code class="docutils literal notranslate"><span class="pre">args</span></code> hem de <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> nesnelerini kabul etmek zorunda olsa da, dönüştürme yaparken bu fonksiyonlar için istediğiniz imzayı belirtebilirsiniz. (İşleviniz anahtar sözcükleri desteklemiyorsa, oluşturulan ayrıştırma işlevi herhangi bir anahtar sözcük alırsa bir istisna atacaktır).</p></li>
</ul>
</section>
<section id="changing-and-redirecting-clinic-s-output">
<h3>Kliniğin çıktısını değiştirme ve yönlendirme<a class="headerlink" href="#changing-and-redirecting-clinic-s-output" title="Permalink to this heading">¶</a></h3>
<p>Kliniğin çıktısının geleneksel elle düzenlenmiş C kodunuzun arasına serpiştirilmesi rahatsız edici olabilir.  Neyse ki, Klinik yapılandırılabilir: çıktısını daha sonra (veya daha önce!) yazdırmak için tamponlayabilir veya çıktısını ayrı bir dosyaya yazabilirsiniz.  Ayrıca Kliniğin ürettiği çıktının her satırına bir önek veya sonek ekleyebilirsiniz.</p>
<p>Kliniğin çıktısını bu şekilde değiştirmek okunabilirlik için bir nimet olsa da, Klinik kodunun tanımlanmadan önce türleri kullanmasına veya kodunuzun tanımlanmadan önce Klinik tarafından oluşturulan kodu kullanmaya çalışmasına neden olabilir. Bu sorunlar, dosyanızdaki bildirimleri yeniden düzenleyerek veya Kliniğin ürettiği kodun yerini değiştirerek kolayca çözülebilir.  (Bu nedenle Kliniğin varsayılan davranışı her şeyi geçerli bloğa çıktı olarak vermektir; birçok kişi bunun okunabilirliği engellediğini düşünse de, kullanımdan önce tanımlama sorunlarını düzeltmek için kodunuzu yeniden düzenlemenizi asla gerektirmez).</p>
<p>Bazı terminolojileri tanımlamakla başlayalım:</p>
<dl>
<dt><em>field</em></dt><dd><p>Bu bağlamda bir alan, Kliniğin çıktısının bir alt bölümüdür. Örneğin, <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> yapısı için <code class="docutils literal notranslate"><span class="pre">#define</span></code> , <code class="docutils literal notranslate"><span class="pre">methoddef_define</span></code> olarak adlandırılan bir alandır.  Kliniğin fonksiyon tanımı başına çıktı verebileceği yedi farklı alan vardır:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>docstring_prototype
docstring_definition
methoddef_define
impl_prototype
parser_prototype
parser_definition
impl_definition
</pre></div>
</div>
<p>Tüm adlar <code class="docutils literal notranslate"><span class="pre">&quot;&lt;a&gt;_&lt;b&gt;&quot;</span></code> biçimindedir, burada <code class="docutils literal notranslate"><span class="pre">&quot;&lt;a&gt;&quot;</span></code> temsil edilen semantik nesnedir (ayrıştırma işlevi, impl işlevi, docstring veya methoddef yapısı) ve <code class="docutils literal notranslate"><span class="pre">&quot;&lt;b&gt;&quot;</span></code> alanın ne tür bir ifade olduğunu temsil eder. <code class="docutils literal notranslate"><span class="pre">&quot;_prototype&quot;</span></code> ile biten alan adları, o şeyin gerçek gövdesi/verileri olmadan ileriye dönük bildirimlerini temsil eder; <code class="docutils literal notranslate"><span class="pre">&quot;_definition&quot;</span></code> ile biten alan adları, o şeyin gövdesi/verileri ile birlikte o şeyin gerçek tanımını temsil eder. (<code class="docutils literal notranslate"><span class="pre">&quot;methoddef&quot;</span></code> özeldir, <code class="docutils literal notranslate"><span class="pre">&quot;_define&quot;</span></code> ile biten tek metottur, #define önişlemcisi olduğunu gösterir.)</p>
</dd>
<dt><em>destination</em></dt><dd><p>Hedef, Kliniğin çıktı yazabileceği bir yerdir.  Beş adet yerleşik hedef vardır:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">block````block</span></code></dt><dd><p>Varsayılan hedef: geçerli Klinik bloğunun çıktı bölümünde yazdırılır.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>Metni daha sonra kullanmak üzere kaydedebileceğiniz bir metin arabelleği.  Buraya gönderilen metin, mevcut metnin sonuna eklenir.  Klinik bir dosyayı işlemeyi bitirdiğinde tamponda herhangi bir metin kalması bir hatadır.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>Klinik tarafından otomatik olarak oluşturulacak ayrı bir “klinik dosyası”. Dosya için seçilen dosya adı <code class="docutils literal notranslate"><span class="pre">{basename}.clinic{extension}</span></code> şeklindedir, burada <code class="docutils literal notranslate"><span class="pre">basename</span></code> ve <code class="docutils literal notranslate"><span class="pre">extension</span></code> mevcut dosya üzerinde çalıştırılan <code class="docutils literal notranslate"><span class="pre">os.path.splitext()</span></code> çıktısına atanmıştır.  (Örnek: <code class="docutils literal notranslate"><span class="pre">_pickle.c</span></code> için <code class="docutils literal notranslate"><span class="pre">dosya</span></code> hedefi <code class="docutils literal notranslate"><span class="pre">_pickle.clinic.c</span></code> olarak yazılacaktır).</p>
<p><strong>Önemli: Bir ** ``dosya`` **hedefi kullanırken, **oluşturulan dosyayı</strong> <strong>mutlaka</strong> kontrol etmelisiniz!</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">two-pass</span></code></dt><dd><p>Arabellek <code class="docutils literal notranslate"><span class="pre">buffer</span></code> gibi bir arabellektir.  Bununla birlikte, iki geçişli bir tampon yalnızca bir kez boşaltılabilir ve boşaltma noktasından <em>sonraki</em> Klinik bloklardan bile tüm işlem sırasında kendisine gönderilen tüm metni yazdırır.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">suppress</span></code></dt><dd><p>Metin bastırılmış, bir kenara atılmıştır.</p>
</dd>
</dl>
</dd>
</dl>
<p>Klinik, çıktısını yeniden yapılandırmanıza olanak tanıyan beş yeni yönerge tanımlar.</p>
<p>İlk yeni yönerge <code class="docutils literal notranslate"><span class="pre">dump</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dump &lt;destination&gt;
</pre></div>
</div>
<p>Bu, adlandırılmış hedefin mevcut içeriğini geçerli bloğun çıktısına döker ve boşaltır.  Bu sadece <code class="docutils literal notranslate"><span class="pre">buffer</span></code> ve <code class="docutils literal notranslate"><span class="pre">two-pass</span></code> hedefleri ile çalışır.</p>
<p>İkinci yeni yönerge ise <code class="docutils literal notranslate"><span class="pre">output</span></code>.  En temel <code class="docutils literal notranslate"><span class="pre">output</span></code> biçimi şöyledir:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>output &lt;field&gt; &lt;destination&gt;
</pre></div>
</div>
<p>Bu, Kliniğe <em>alan</em> çıktısını <em>hedefe</em> vermesini söyler.  <code class="docutils literal notranslate"><span class="pre">output</span></code> ayrıca <code class="docutils literal notranslate"><span class="pre">everything</span></code> adı verilen ve Kliniğe <em>tüm</em> alanların çıktısını bu <em>hedefe</em> vermesini söyleyen özel bir meta hedefi de destekler.</p>
<p><code class="docutils literal notranslate"><span class="pre">output</span></code> bir dizi başka işleve sahiptir:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>output push
output pop
output preset &lt;preset&gt;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">push</span></code> ve <code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">pop</span></code> dahili bir yapılandırma yığınında yapılandırmaları itmenize ve açmanıza izin verir, böylece çıkış yapılandırmasını geçici olarak değiştirebilir ve ardından önceki yapılandırmayı kolayca geri yükleyebilirsiniz.  Geçerli yapılandırmayı kaydetmek için değişikliğinizden önce push yapmanız, ardından önceki yapılandırmayı geri yüklemek istediğinizde pop yapmanız yeterlidir.</p>
<p><code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">preset</span></code> Kliniğin çıkışını aşağıdaki gibi çeşitli yerleşik ön ayar yapılandırmalarından birine ayarlar:</p>
<blockquote>
<div><dl>
<dt><code class="docutils literal notranslate"><span class="pre">block````block</span></code></dt><dd><p>Kliniğin orijinal başlangıç yapılandırması.  Giriş bloğundan hemen sonra her şeyi yazar.</p>
<p>Suppress the <code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code>
and <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code>, write everything else to <code class="docutils literal notranslate"><span class="pre">block</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>Yapabildiği her şeyi “klinik dosyasına” yazmak için tasarlanmıştır. Daha sonra bu dosyayı dosyanızın en üstüne yakın bir yere <code class="docutils literal notranslate"><span class="pre">#include</span></code> edersiniz. Bunun çalışması için dosyanızı yeniden düzenlemeniz gerekebilir, ancak genellikle bu sadece çeşitli <code class="docutils literal notranslate"><span class="pre">typedef</span></code> ve <code class="docutils literal notranslate"><span class="pre">PyTypeObject</span></code> tanımları için ileri bildirimler oluşturmak anlamına gelir.</p>
<p><code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code> ve <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code> öğelerini bastırın, <code class="docutils literal notranslate"><span class="pre">impl_definition</span></code> öğesini <code class="docutils literal notranslate"><span class="pre">block</span></code> öğesine yazın ve diğer her şeyi <code class="docutils literal notranslate"><span class="pre">file</span></code> öğesine yazın.</p>
<p>Varsayılan dosya adı <code class="docutils literal notranslate"><span class="pre">&quot;{dirname}/clinic/{basename}.h&quot;</span></code> şeklindedir.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>Clinic’ten gelen çıktının çoğunu, sonuna yakın dosyanıza yazılmak üzere kaydedin.  Modülleri veya yerleşik tipleri uygulayan Python dosyaları için, tamponu modülünüz veya yerleşik tipiniz için statik yapıların hemen üzerine boşaltmanız önerilir; bunlar normalde sona çok yakındır.  Dosyanızın ortasında tanımlanmış statik <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> dizileri varsa, <code class="docutils literal notranslate"><span class="pre">buffer</span></code> kullanmak <code class="docutils literal notranslate"><span class="pre">file</span></code> kullanmaktan daha fazla düzenleme gerektirebilir.</p>
<p><code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code>, <code class="docutils literal notranslate"><span class="pre">impl_prototype</span></code> ve <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code> öğelerini bastırın, <code class="docutils literal notranslate"><span class="pre">impl_definition</span></code> öğesini <code class="docutils literal notranslate"><span class="pre">block</span></code> öğesine yazın ve diğer her şeyi <code class="docutils literal notranslate"><span class="pre">file</span></code> öğesine yazın.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">two-pass</span></code></dt><dd><p>Bu <code class="docutils literal notranslate"><span class="pre">buffer</span></code> ön ayarına benzer, ancak ileri bildirimleri <code class="docutils literal notranslate"><span class="pre">two-pass</span></code> tamponuna ve tanımları <code class="docutils literal notranslate"><span class="pre">buffer</span></code> tamponuna yazar. Bu <code class="docutils literal notranslate"><span class="pre">buffer</span></code> ön ayarına benzer, ancak <code class="docutils literal notranslate"><span class="pre">buffer</span></code>’dan daha az düzenleme gerektirebilir.  Dosyanızın üst kısmına yakın <code class="docutils literal notranslate"><span class="pre">two-pass</span></code> tamponunu boşaltın ve <code class="docutils literal notranslate"><span class="pre">buffer</span></code> ön ayarını kullanırken yaptığınız gibi sonuna yakın <code class="docutils literal notranslate"><span class="pre">buffer</span></code>’ı boşaltın.</p>
<p><code class="docutils literal notranslate"><span class="pre">impl_prototype</span></code>’ı bastırır, <code class="docutils literal notranslate"><span class="pre">impl_definition</span></code>’ı <code class="docutils literal notranslate"><span class="pre">block</span></code>’a yazar, <code class="docutils literal notranslate"><span class="pre">docstring_prototype</span></code>, <code class="docutils literal notranslate"><span class="pre">methoddef_define</span></code> ve <code class="docutils literal notranslate"><span class="pre">parser_prototype</span></code>’ı <code class="docutils literal notranslate"><span class="pre">two-pass</span></code>’a yazar, diğer her şeyi <code class="docutils literal notranslate"><span class="pre">buffer</span></code>’a yazar.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">partial-buffer</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">buffer</span></code> ön ayarına benzer, ancak <code class="docutils literal notranslate"><span class="pre">block</span></code>’a daha fazla şey yazar, yalnızca oluşturulan kodun gerçekten büyük parçalarını <code class="docutils literal notranslate"><span class="pre">buffer</span></code>’a yazar. Bu, bloğun çıktısında biraz daha fazla şey olması gibi küçük bir maliyetle, <code class="docutils literal notranslate"><span class="pre">buffer</span></code>’ın kullanımdan önce tanımlama sorununu tamamen ortadan kaldırır. Tıpkı <code class="docutils literal notranslate"><span class="pre">buffer</span></code> ön ayarını kullanırken yaptığınız gibi, <code class="docutils literal notranslate"><span class="pre">buffer</span></code>’ı sonuna doğru boşaltın.</p>
<p><code class="docutils literal notranslate"><span class="pre">impl_prototype</span></code> ı bastırır, <code class="docutils literal notranslate"><span class="pre">docstring_definition</span></code> ve <code class="docutils literal notranslate"><span class="pre">parser_definition</span></code> ı <code class="docutils literal notranslate"><span class="pre">buffer</span></code> a yazar, diğer her şeyi <code class="docutils literal notranslate"><span class="pre">block</span></code> a yazar.</p>
</dd>
</dl>
</div></blockquote>
<p>Üçüncü yeni yönerge <code class="docutils literal notranslate"><span class="pre">destination</span></code> dır:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>destination &lt;name&gt; &lt;command&gt; [...]
</pre></div>
</div>
<p>Bu, <code class="docutils literal notranslate"><span class="pre">name</span></code> adlı hedef üzerinde bir işlem gerçekleştirir.</p>
<p>Tanımlanmış iki alt komut vardır: <code class="docutils literal notranslate"><span class="pre">new</span></code> ve <code class="docutils literal notranslate"><span class="pre">clear</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">new</span></code> alt komutu şu şekilde çalışır:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>destination &lt;name&gt; new &lt;type&gt;
</pre></div>
</div>
<p>Bu, adı <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code> ve türü <code class="docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code> olan yeni bir hedef oluşturur.</p>
<p>Beş hedef türü vardır:</p>
<blockquote>
<div><dl>
<dt><code class="docutils literal notranslate"><span class="pre">suppress</span></code></dt><dd><p>Metni atıyor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">block````block</span></code></dt><dd><p>Metni geçerli bloğa yazar.  Kliniğin başlangıçta yaptığı budur.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">buffer</span></code></dt><dd><p>Yukarıdaki “buffer” yerleşik hedefi gibi basit bir metin tamponu.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">file</span></code></dt><dd><p>Bir metin dosyası.  Dosya hedefi, dosya adını oluşturmak için kullanılacak bir şablon olan ekstra bir argüman alır, aşağıdaki gibi:</p>
<blockquote>
<div><p>hedef &lt;isim&gt; yeni &lt;tip&gt; &lt;dosya_şablonu&gt;</p>
</div></blockquote>
<p>Şablon dahili olarak dosya adının bitleriyle değiştirilecek üç dizge kullanabilir:</p>
<blockquote>
<div><dl class="simple">
<dt>{path}</dt><dd><p>Dizin ve tam dosya adı dahil olmak üzere dosyanın tam yolu.</p>
</dd>
<dt>{dirname}</dt><dd><p>Dosyanın içinde bulunduğu dizinin adı.</p>
</dd>
<dt>{basename}</dt><dd><p>Sadece dosyanın adı, dizin dahil değil.</p>
</dd>
<dt>{basename_root}</dt><dd><p>Uzantısı kırpılmış temel ad (son ‘.’ dahil olmak üzere her şey).</p>
</dd>
<dt>{basename_extension}</dt><dd><p>Son ‘.’ ve ondan sonraki her şey.  Ana ad nokta içermiyorsa, bu boş bir dize olacaktır.</p>
</dd>
</dl>
</div></blockquote>
<p>Dosya adında nokta yoksa, {basename} ve {filename} aynıdır ve {extension} boştur.  “{basename}{extension}” her zaman “{filename}” ile tamamen aynıdır.”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">two-pass</span></code></dt><dd><p>Yukarıdaki “iki geçişli” yerleşik hedef gibi iki geçişli bir tampon.</p>
</dd>
</dl>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">clear</span></code> alt komutu şu şekilde çalışır:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>destination &lt;name&gt; clear
</pre></div>
</div>
<p>Hedefte bu noktaya kadar birikmiş tüm metni kaldırır. (Buna ne için ihtiyaç duyacağınızı bilmiyorum, ancak birileri deneme yaparken belki yararlı olabileceğini düşündüm).</p>
<p>Dördüncü yeni yönerge <code class="docutils literal notranslate"><span class="pre">set</span></code>’tir:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set line_prefix &quot;string&quot;
set line_suffix &quot;string&quot;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">set</span></code> Klinikte iki dahili değişkeni ayarlamanızı sağlar. <code class="docutils literal notranslate"><span class="pre">line_prefix</span></code>, Kliniğin çıktısının her satırına eklenecek bir dizedir; <code class="docutils literal notranslate"><span class="pre">line_suffix</span></code>, Kliniğin çıktısının her satırına eklenecek bir dizedir.</p>
<p>Bunların her ikisi de iki biçim dizesini destekler:</p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">comment</span> <span class="pre">start}</span></code></dt><dd><p>C dosyaları için başlangıç-yorum metin dizisi olan <code class="docutils literal notranslate"><span class="pre">/*</span></code> dizesine dönüşür.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{block</span> <span class="pre">comment</span> <span class="pre">end}</span></code></dt><dd><p>C dosyaları için yorum sonu metin dizisi olan <code class="docutils literal notranslate"><span class="pre">*/</span></code> dizesine dönüşür.</p>
</dd>
</dl>
</div></blockquote>
<p>Son yeni yönerge doğrudan kullanmanız gerekmeyen bir yönerge olup <code class="docutils literal notranslate"><span class="pre">preserve</span></code> olarak adlandırılmıştır:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>preserve
</pre></div>
</div>
<p>Bu, Clinic’e çıktının mevcut içeriğinin değiştirilmeden tutulması gerektiğini söyler. Bu, çıktıyı <code class="docutils literal notranslate"><span class="pre">file</span></code> dosyalarına dökerken Clinic tarafından dahili olarak kullanılır; bunu bir Clinic bloğuna sarmak, dosyanın üzerine yazılmadan önce elle değiştirilmediğinden emin olmak için Clinic’in mevcut sağlama toplamı işlevini kullanmasını sağlar.</p>
</section>
<section id="the-ifdef-trick">
<h3>#ifdef hilesi<a class="headerlink" href="#the-ifdef-trick" title="Permalink to this heading">¶</a></h3>
<p>Tüm platformlarda bulunmayan bir fonksiyonu dönüştürüyorsanız, hayatı biraz daha kolaylaştırmak için kullanabileceğiniz bir numara var.  Mevcut kod muhtemelen şuna benzer:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef HAVE_FUNCTIONNAME</span>
<span class="k">static</span><span class="w"> </span><span class="n">module_functionname</span><span class="p">(...)</span>
<span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* HAVE_FUNCTIONNAME */</span>
</pre></div>
</div>
<p>Ve sonra alttaki <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> yapısında mevcut kod olacaktır:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#ifdef HAVE_FUNCTIONNAME
{&#39;functionname&#39;, ... },
#endif /* HAVE_FUNCTIONNAME */
</pre></div>
</div>
<p>Bu senaryoda, impl fonksiyonunuzun gövdesini aşağıdaki gibi <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code> içine almalısınız:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef HAVE_FUNCTIONNAME</span>
<span class="cm">/*[clinic input]</span>
<span class="cm">module.functionname</span>
<span class="cm">...</span>
<span class="cm">[clinic start generated code]*/</span>
<span class="k">static</span><span class="w"> </span><span class="n">module_functionname</span><span class="p">(...)</span>
<span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* HAVE_FUNCTIONNAME */</span>
</pre></div>
</div>
<p>Ardından, bu üç satırı <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> yapısından kaldırın ve bunların yerine Argument Clinic makrosunu oluşturun:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>MODULE_FUNCTIONNAME_METHODDEF
</pre></div>
</div>
<p>(Bu makronun gerçek adını oluşturulan kodun içinde bulabilirsiniz. Ya da kendiniz hesaplayabilirsiniz: bloğunuzun ilk satırında tanımlanan fonksiyonunuzun adıdır, ancak noktalar alt çizgi olarak değiştirilir, büyük harfle yazılır ve sonuna <code class="docutils literal notranslate"><span class="pre">&quot;_METHODDEF&quot;</span></code> eklenir)</p>
<p>Belki de merak ediyorsunuzdur: <code class="docutils literal notranslate"><span class="pre">HAVE_FUNCTIONNAME</span></code> tanımlanmamışsa ne olur? ‘’MODULE_FUNCTIONNAME_METHODDEF’’ makrosu da tanımlanmayacaktır!</p>
<p>Argüman Kliniği burada çok akıllıca davranır.  Aslında Argüman Kliniği bloğunun <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code> tarafından devre dışı bırakılabileceğini algılar.  Bu olduğunda, şuna benzeyen küçük bir ekstra kod oluşturur:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef MODULE_FUNCTIONNAME_METHODDEF</span>
<span class="w">    </span><span class="cp">#define MODULE_FUNCTIONNAME_METHODDEF</span>
<span class="cp">#endif </span><span class="cm">/* !defined(MODULE_FUNCTIONNAME_METHODDEF) */</span>
</pre></div>
</div>
<p>Bu, makronun her zaman çalıştığı anlamına gelir.  İşlev tanımlıysa, bu, sondaki virgül de dahil olmak üzere doğru yapıya dönüşür.  İşlev tanımlanmamışsa, bu hiçbir şeye dönüşmez.</p>
<p>Ancak bu, can sıkıcı bir soruna neden olmaktadır: Argüman Kliniği “blok” çıktı ön ayarını kullanırken bu ekstra kodu nereye koymalıdır?  Çıkış bloğuna koyulamaz, çünkü <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code> tarafından devre dışı bırakılabilir.  (Bütün mesele bu!)</p>
<p>Bu durumda, Argüman Kliniği ekstra kodu “tampon” hedefine yazar. Bu, Argüman Kliniği’nden bir şikayet almanız anlamına gelebilir:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Warning in file &quot;Modules/posixmodule.c&quot; on line 12357:
Destination buffer &#39;buffer&#39; not empty at end of file, emptying.
</pre></div>
</div>
<p>Bu olduğunda, dosyanızı açın, Argüman Kliniği’nin dosyanıza eklediği <code class="docutils literal notranslate"><span class="pre">dump</span> <span class="pre">buffer</span></code> bloğunu bulun (en altta olacaktır), ardından bu makronun kullanıldığı <code class="docutils literal notranslate"><span class="pre">PyMethodDef</span></code> yapısının üzerine taşıyın.</p>
</section>
<section id="using-argument-clinic-in-python-files">
<h3>Python dosyalarında Argüman Kliniği kullanma<a class="headerlink" href="#using-argument-clinic-in-python-files" title="Permalink to this heading">¶</a></h3>
<p>Aslında Python dosyalarını önceden işlemek için Argüman Kliniği kullanmak mümkündür. Argüman Kliniği bloklarını kullanmanın bir anlamı yok elbette, çünkü çıktı Python yorumlayıcısı için bir anlam ifade etmeyecektir.  Ancak Python bloklarını çalıştırmak için Argüman Kliniği’ni kullanmak Python’u bir Python önişlemcisi olarak kullanmanızı sağlar!</p>
<p>Python yorumları C yorumlarından farklı olduğu için, Python dosyalarına gömülü Argüman Kliniği blokları biraz farklı görünür.  Şöyle görünürler:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#/*[python input]</span>
<span class="c1">#print(&quot;def foo(): pass&quot;)</span>
<span class="c1">#[python start generated code]*/</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span> <span class="k">pass</span>
<span class="c1">#/*[python checksum:...]*/</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">İçindekiler</a></h3>
    <ul>
<li><a class="reference internal" href="#">Argüman Kliniği Nasıl Yapılır</a><ul>
<li><a class="reference internal" href="#the-goals-of-argument-clinic">Argüman Kliniğinin Hedefleri</a></li>
<li><a class="reference internal" href="#basic-concepts-and-usage">Temel Kavramlar ve Kullanım</a></li>
<li><a class="reference internal" href="#converting-your-first-function">İlk Fonksiyonunuzu Dönüştürme</a></li>
<li><a class="reference internal" href="#advanced-topics">İleri Düzey Konular</a><ul>
<li><a class="reference internal" href="#symbolic-default-values">Sembolik varsayılan değerler</a></li>
<li><a class="reference internal" href="#renaming-the-c-functions-and-variables-generated-by-argument-clinic">Argüman Kliniği tarafından oluşturulan C işlevlerini ve değişkenlerini yeniden adlandırma</a></li>
<li><a class="reference internal" href="#converting-functions-using-pyarg-unpacktuple">PyArg_UnpackTuple kullanarak fonksiyonları dönüştürme</a></li>
<li><a class="reference internal" href="#optional-groups">İsteğe Bağlı Gruplar</a></li>
<li><a class="reference internal" href="#using-real-argument-clinic-converters-instead-of-legacy-converters">“Eski dönüştürücüler” yerine gerçek Argüman Kliniği dönüştürücülerinin kullanılması</a></li>
<li><a class="reference internal" href="#py-buffer">Py_buffer</a></li>
<li><a class="reference internal" href="#advanced-converters">Gelişmiş dönüştürücüler</a></li>
<li><a class="reference internal" href="#parameter-default-values">Parametre varsayılan değerleri</a></li>
<li><a class="reference internal" href="#the-null-default-value">Varsayılan değer <code class="docutils literal notranslate"><span class="pre">NULL</span></code></a></li>
<li><a class="reference internal" href="#expressions-specified-as-default-values">Varsayılan değerler olarak belirtilen ifadeler</a></li>
<li><a class="reference internal" href="#using-a-return-converter">Dönüş dönüştürücüsü kullanma</a></li>
<li><a class="reference internal" href="#cloning-existing-functions">Mevcut fonksiyonları klonlama</a></li>
<li><a class="reference internal" href="#calling-python-code">Python kodunu çağırma</a></li>
<li><a class="reference internal" href="#using-a-self-converter">“Kendi kendine dönüştürücü” kullanma</a></li>
<li><a class="reference internal" href="#using-a-defining-class-converter">“Sınıf tanımlama” dönüştürücüsü kullanma</a></li>
<li><a class="reference internal" href="#writing-a-custom-converter">Özel bir dönüştürücü yazma</a></li>
<li><a class="reference internal" href="#writing-a-custom-return-converter">Özel bir dönüş dönüştürücü yazma</a></li>
<li><a class="reference internal" href="#meth-o-and-meth-noargs">METH_O ve METH_NOARGS</a></li>
<li><a class="reference internal" href="#tp-new-and-tp-init-functions">tp_new ve tp_init fonksiyonları</a></li>
<li><a class="reference internal" href="#changing-and-redirecting-clinic-s-output">Kliniğin çıktısını değiştirme ve yönlendirme</a></li>
<li><a class="reference internal" href="#the-ifdef-trick">#ifdef hilesi</a></li>
<li><a class="reference internal" href="#using-argument-clinic-in-python-files">Python dosyalarında Argüman Kliniği kullanma</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Önceki konu</h4>
    <p class="topless"><a href="ipaddress.html"
                          title="önceki bölüm">An introduction to the ipaddress module</a></p>
  </div>
  <div>
    <h4>Sonraki konu</h4>
    <p class="topless"><a href="instrumentation.html"
                          title="sonraki bölüm">Instrumenting CPython with DTrace and SystemTap</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Bu Sayfa</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Hata Bildir</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/howto/clinic.rst"
            rel="nofollow">Kaynağı Göster
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Yan çubuğu daralt">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Gezinti</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Genel Endeks"
             >dizin</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Modül Dizini"
             >modülleri</a> |</li>
        <li class="right" >
          <a href="instrumentation.html" title="Instrumenting CPython with DTrace and SystemTap"
             >sonraki</a> |</li>
        <li class="right" >
          <a href="ipaddress.html" title="An introduction to the ipaddress module"
             >önceki</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python NASIL’ları</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Argüman Kliniği Nasıl Yapılır</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Hızlı Arama" aria-label="Hızlı Arama" type="search" name="q" />
          <input type="submit" value="Git" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Telif Hakkı</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    Son güncelleme: Haz 28, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.2.0.
    </div>

  </body>
</html>